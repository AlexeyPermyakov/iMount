
#Область ПрограммныйИнтерфейс

#Область ПрограммныйИнтерфейсУБХ

// Процедура обновляет таблицу значений на форме со списком объектов площадки.
//
// Параметры:
//  Площадка  - справочник ссылка УБХПлощадки.
//  ТаблицаОС - таблица значений с полями "ОбъектПлощадки, КодОбъекта, ТипОбъекта, Статус" для обновления объектов площадки.
//
Процедура ОбновитьСоставСвязанныхОС(Площадка, ТаблицаОС, ТекущийОбъект) Экспорт
	
	ТаблицаОС.Очистить();
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	УБХОбъектыПлощадок.ОбъектПлощадки КАК ОбъектПлощадки,
		|	УБХОбъектыПлощадок.ОбъектПлощадки.Статус КАК Статус,
		|	ВЫБОР
		|		КОГДА ТИПЗНАЧЕНИЯ(УБХОбъектыПлощадок.ОбъектПлощадки) = ТИП(Справочник.УБХЗемельныеУчастки)
		|			ТОГДА УБХОбъектыПлощадок.ОбъектПлощадки.КадастровыйНомер
		|		ИНАЧЕ УБХОбъектыПлощадок.ОбъектПлощадки.Код
		|	КОНЕЦ КАК КодОбъекта,
		|	ВЫБОР
		|		КОГДА ТИПЗНАЧЕНИЯ(УБХОбъектыПлощадок.ОбъектПлощадки) = ТИП(Справочник.УБХАМС)
		|			ТОГДА ""АМС""
		|		КОГДА ТИПЗНАЧЕНИЯ(УБХОбъектыПлощадок.ОбъектПлощадки) = ТИП(Справочник.УБХВЛЭС)
		|			ТОГДА ""ВЛЭС""
		|		КОГДА ТИПЗНАЧЕНИЯ(УБХОбъектыПлощадок.ОбъектПлощадки) = ТИП(Справочник.УБХЗемельныеУчастки)
		|			ТОГДА ""Зем. участок""
		|		КОГДА ТИПЗНАЧЕНИЯ(УБХОбъектыПлощадок.ОбъектПлощадки) = ТИП(Справочник.УБХКТП)
		|			ТОГДА ""КТП""
		|		КОГДА ТИПЗНАЧЕНИЯ(УБХОбъектыПлощадок.ОбъектПлощадки) = ТИП(Справочник.УБХОсновныеСредства)
		|			ТОГДА ""Основное средство""
		|		ИНАЧЕ """"
		|	КОНЕЦ КАК ТипОбъекта
		|ИЗ
		|	РегистрСведений.УБХОбъектыПлощадок КАК УБХОбъектыПлощадок
		|ГДЕ
		|	УБХОбъектыПлощадок.Площадка = &Площадка
		|	И НЕ УБХОбъектыПлощадок.ОбъектПлощадки = &ТекущийОбъект";
	
	Запрос.УстановитьПараметр("Площадка", 		Площадка);
	Запрос.УстановитьПараметр("ТекущийОбъект", 	ТекущийОбъект);
	
	РезультатЗапроса = Запрос.Выполнить();
	
	Если РезультатЗапроса.Пустой() Тогда		
		Возврат;
	КонецЕсли;
	
	ТаблицаОС.Загрузить(РезультатЗапроса.Выгрузить());
	
КонецПроцедуры

#Область УправлениеНСИ

Процедура ПриЗаписиПлощадки(Источник, Отказ) Экспорт
	
	Если Источник.ДополнительныеСвойства.Свойство("ЗаписыватьОбъектыПлощадки")
		И Источник.ДополнительныеСвойства.ЗаписыватьОбъектыПлощадки Тогда
		ЗаписатьОбъектыПлощадки(Источник);
		ЗаписатьПлощадкуПоОбъектам(Источник);
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти

#КонецОбласти

#Область МетодыРаботыАвтозаполненияРеквизитовДокумента

// Служебная функция, предназначенная для получения описания типов числа, заданной разрядности.
// 
// Параметры:
//  Разрядность 			- число, разряд числа.
//  РазрядностьДробнойЧасти - число, разряд дробной части.
//  Неотрицательный - Булево, если Истина, то числа только положительные, если Ложь, то любые.
//
// Возвращаемое значение:
//  Объект "ОписаниеТипов" для числа указанной разрядности.
//
Функция ПолучитьОписаниеТиповЧисла(Разрядность, РазрядностьДробнойЧасти, Неотрицательный = Ложь) Экспорт
	
	Если Неотрицательный Тогда
		Знак = ДопустимыйЗнак.Неотрицательный;
	Иначе
		Знак = ДопустимыйЗнак.Любой;
	КонецЕсли;
	
	Возврат Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(Разрядность, РазрядностьДробнойЧасти, Знак));

КонецФункции // ПолучитьОписаниеТиповЧисла()

// Служебная функция, предназначенная для получения описания типов даты
// 
// Параметры:
//  ЧастиДаты - системное перечисление ЧастиДаты.
// 
Функция ПолучитьОписаниеТиповДаты(ЧастиДаты) Экспорт

	Возврат Новый ОписаниеТипов("Дата", , , Новый КвалификаторыДаты(ЧастиДаты));

КонецФункции // ПолучитьОписаниеТиповДаты()

// Дополняет одну таблицу значений строками другой таблицы значений
//
// Параметры:
//	Приемник			- произвольная коллекция, в которую добавляются строки
//	Источник 			- произвольная коллекция, из которой берутся добавляемые строки
//	СоответствиеПолей	- Соответствие - используется чтобы заполнить поля с разными названиями, 
//										ключ содержит имя поля приемника, значение содержит имя поля источника.
//
Процедура ДобавитьСтрокиВТаблицу(Приемник, Источник, СоответствиеПолей = Неопределено) Экспорт

	Для каждого СтрокаИсточника Из Источник Цикл
		НоваяСтрока = Приемник.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, СтрокаИсточника);
		Если СоответствиеПолей <> Неопределено Тогда
			Для каждого КлючИЗначение Из СоответствиеПолей Цикл
				НоваяСтрока[КлючИЗначение.Ключ] = СтрокаИсточника[КлючИЗначение.Значение];
			КонецЦикла; 
		КонецЕсли; 
	КонецЦикла;

КонецПроцедуры

// Заполняет колонку таблицы значений последовательными номерами
//
// Параметры:
//	Таблица - таблица значений, строки которой нужно пронумеровать
//	ИмяКолонкиНомераСтроки - колонка таблицы значений, в которой будут указаны номера строк.
//
Процедура ПронумероватьТаблицуЗначений(Таблица, ИмяКолонкиНомераСтроки) Экспорт

	Если Таблица.Колонки.Найти(ИмяКолонкиНомераСтроки) = Неопределено Тогда
		Таблица.Колонки.Добавить(ИмяКолонкиНомераСтроки, ПолучитьОписаниеТиповЧисла(15, 0));
	КонецЕсли;

	КоличествоСтрок = Таблица.Количество() - 1;
	Для НомерСтроки = 0 По КоличествоСтрок Цикл
		Таблица[НомерСтроки][ИмяКолонкиНомераСтроки] = НомерСтроки;
	КонецЦикла;

КонецПроцедуры

// Выгружает таблицу значений из ДанныеФормыКоллекция и ТабличнаяЧасть
//
// Параметры:
// 		ТаблицаИсточник - ДанныеФормыКоллекция, ТабличнаяЧасть - Таблица источник выгрузки
// 		Строки - Массив, Структура - Массив строк для выгрузки или структура отбора
// 		Колонки - Строка - Перечисленные через запятую имена колонок для выгрузки
// 		КолонкиПоЗначению - Структура - Структура колонок для добавление в результирующую таблицу:
// 										Ключ - Имя новой колонки
// 										Значение - Значение для подстановки по все строки новой колонки
// 		НовыеИменаКолонок - Структура - Структура с данными о переименовании колонок в результирующей таблице:
// 										Ключ - Текущее имя колонки
// 										Значение - Новое имя колонки.
//
// Возвращаемое значение:
// 		ТаблицаЗначений - Таблица результат выгрузки из таблицы источника с добавленными и переименованными колонками.
//
Функция ВыгрузитьТаблицуЗначений(ТаблицаИсточник, Строки = Неопределено, Колонки = "НомерСтроки",
			Знач КолонкиПоЗначению = Неопределено, Знач НовыеИменаКолонок = Неопределено) Экспорт
	
	// Определение значений по умолчанию
	Если КолонкиПоЗначению = Неопределено Тогда
		КолонкиПоЗначению = Новый Структура;
	КонецЕсли;
	Если НовыеИменаКолонок = Неопределено Тогда
		НовыеИменаКолонок = Новый Структура;
	КонецЕсли;
	
	// Определить список выгружаемых колонок
	СтруктураДругихИменКолонок = Новый Структура;
	Для Каждого НовоеИмя Из НовыеИменаКолонок Цикл
		СтруктураДругихИменКолонок.Вставить(НовоеИмя.Значение, НовоеИмя.Ключ);
	КонецЦикла;
	ИменаКолонок = "";
	ИмяКолонки = "";
	СтруктураКолонок = Новый Структура(Колонки);
	Для Каждого Колонка Из СтруктураКолонок Цикл
		Если Не СтруктураДругихИменКолонок.Свойство(Колонка.Ключ, ИмяКолонки) Тогда
			ИмяКолонки = Колонка.Ключ;
		КонецЕсли;
		Если Не КолонкиПоЗначению.Свойство(ИмяКолонки) Тогда
			ИменаКолонок = ИменаКолонок + ", " + ИмяКолонки;
		КонецЕсли;
	КонецЦикла;
	
	// Выгрузить из таблицы источника
	Если ТипЗнч(ТаблицаИсточник) = Тип("ТаблицаЗначений") Тогда
		ТаблицаРезультата = ТаблицаИсточник.Скопировать(Строки, Сред(ИменаКолонок, 3));
	Иначе
		ТаблицаРезультата = ТаблицаИсточник.Выгрузить(Строки, Сред(ИменаКолонок, 3));
	КонецЕсли;
	
	// Добавить новые колонки в таблицу результата
	Если КолонкиПоЗначению <> Неопределено Тогда
		Для Каждого Колонка Из КолонкиПоЗначению Цикл
			МассивТипов = Новый Массив;
			МассивТипов.Добавить(ТипЗнч(Колонка.Значение));
			ТаблицаРезультата.Колонки.Добавить(Колонка.Ключ, Новый ОписаниеТипов(МассивТипов));
			ТаблицаРезультата.ЗаполнитьЗначения(Колонка.Значение, Колонка.Ключ);
		КонецЦикла;
	КонецЕсли;
	
	// Переименовать колонки в таблице результата
	Если НовыеИменаКолонок <> Неопределено Тогда
		Для Каждого Колонка Из НовыеИменаКолонок Цикл
			ТаблицаРезультата.Колонки[Колонка.Ключ].Имя = Колонка.Значение;
		КонецЦикла;
	КонецЕсли;
	
	Возврат ТаблицаРезультата;
	
КонецФункции // ВыгрузитьТаблицуЗначений()

// Заполняет идентификатор строк в таблице значений
//
// Параметры:
//  Таблица				 - ТаблицаЗначений	 - таблица значений, строки которой нужно пронумеровать
//  ИмяКолонки			 - Строка			 - колонка таблицы значений, в которой будут заполнены идентификаторы.
//  ТипИдентификатора	 - Строка			 - тип идентификатора ("Число", "УникальныйИдентификатор")
//
Процедура ДобавитьИдентификаторСтрокВТаблицу(Таблица, ИмяКолонки = "Идентификатор", ТипИдентификатора = "Число") Экспорт

	Если ТипИдентификатора = "Число" Тогда

		Если Таблица.Колонки.Найти(ИмяКолонки) = Неопределено Тогда
			Таблица.Колонки.Добавить(ИмяКолонки, Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(15, 0, ДопустимыйЗнак.Неотрицательный)));
		КонецЕсли;
		
		Для НомерСтроки = 0 По Таблица.Количество() - 1 Цикл
			Таблица[НомерСтроки][ИмяКолонки] = НомерСтроки + 1;
		КонецЦикла;
		
	ИначеЕсли ТипИдентификатора = "УникальныйИдентификатор" Тогда
		
		Если Таблица.Колонки.Найти(ИмяКолонки) = Неопределено Тогда
			Таблица.Колонки.Добавить(ИмяКолонки, Новый ОписаниеТипов("УникальныйИдентификатор"));
		КонецЕсли;
		
		Для НомерСтроки = 0 По Таблица.Количество() - 1 Цикл
			Таблица[НомерСтроки][ИмяКолонки] = Новый УникальныйИдентификатор;
		КонецЦикла;
		
	КонецЕсли;

КонецПроцедуры

// Процедура делает запись в журнал регистрации и сообщает пользователю, если это сообщение об ошибке 
// Параметры:
//   ПараметрыЖурнала - Структура - параметры записи в журнал регистрации
//			Свойства:
//       		ГруппаСобытий - Строка - префикс для имени события журнала регистрации
//       		Метаданные - ОбъектМетаданных - метаданные для записи в журнал регистрации
//       		Данные - Произвольный - данные для записи в журнал регистрации
//   ИмяСобытия - Строка  - имя события (в журнал событие записывается в формате ГруппаСобытий.ИмяСобытия)
//   Уровень - УровеньЖурналаРегистрации  - Соответствует уровням журнала регистрации
//   Комментарий - Строка - комментарий о событии
//   ИнформацияОбОшибке - ИнформацияОбОшибке, Строка - Информация об ошибке, которую так же необходимо задокументировать
//                                                     в комментарии журнала регистрации.
//
Процедура ЗаписатьВЖурналСообщитьПользователю(ПараметрыЖурнала, УровеньЖурнала, ИмяСобытия, Знач Комментарий = "", ИнформацияОбОшибке = Неопределено) Экспорт
	
	Если ТипЗнч(ИнформацияОбОшибке) = Тип("ИнформацияОбОшибке") Тогда
		Если Комментарий = "" Тогда
			ТестСообщенияПользователю = КраткоеПредставлениеОшибки(ИнформацияОбОшибке);
			Комментарий = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке);
		Иначе
			ТестСообщенияПользователю = Комментарий + Символы.ПС + КраткоеПредставлениеОшибки(ИнформацияОбОшибке);
			Комментарий = Комментарий + Символы.ПС + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке);
		КонецЕсли;
	Иначе
		Если ТипЗнч(ИнформацияОбОшибке) = Тип("Строка") 
			И Не ПустаяСтрока(ИнформацияОбОшибке) Тогда
			Комментарий = Комментарий + Символы.ПС + ИнформацияОбОшибке;
		КонецЕсли;
		ТестСообщенияПользователю = Комментарий;
	КонецЕсли;
	
	// Журнал регистрации 
	УстановитьПривилегированныйРежим(Истина);
	ЗаписьЖурналаРегистрации(
	    СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru='%1'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
			ПараметрыЖурнала.ГруппаСобытий + ?(ИмяСобытия = "", "", "." + ИмяСобытия)),
		УровеньЖурнала, 
		ПараметрыЖурнала.Метаданные, 
		ПараметрыЖурнала.Данные, 
		Комментарий);
	УстановитьПривилегированныйРежим(Ложь);
	
	Если УровеньЖурнала = УровеньЖурналаРегистрации.Ошибка 
		Или УровеньЖурнала = УровеньЖурналаРегистрации.Предупреждение Тогда
		
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю(СокрЛП(ТестСообщенияПользователю),ПараметрыЖурнала.Данные);
	КонецЕсли;
	
КонецПроцедуры

// Функция возвращает изменения документа, относительно записанного в базе
// 
// Параметры:
// 	Объект - ДокументОбъект - Документ, изменение которого необходимо проанализировать
// 	РеквизитыИсключения - Структура - Структура имен реквизитов, изменение которых проверять не требуется
// 	ТабличныеЧастиИсключения - Структура - Структура имен табличных частей, изменение которых проверять не требуется.
//
// Возвращаемое значение:
// 	Структура - Структура - Содержит изменения объекта:
// 								- по ключу "Реквизиты" - таблица измененных реквизитов
// 								- по ключу "ТабличныеЧасти" - структура низменных табличных частей.
Функция ИзмененияДокумента(Объект, РеквизитыИсключения = Неопределено, ТабличныеЧастиИсключения = Неопределено) Экспорт
	
	Результат = Новый Структура;
	
	Если РеквизитыИсключения = Неопределено Тогда
		РеквизитыИсключения = Новый Структура;
	КонецЕсли;
	
	Если ТабличныеЧастиИсключения = Неопределено Тогда
		ТабличныеЧастиИсключения = Новый Структура;
	КонецЕсли;
	
	МетаданныеДокумента = Объект.Метаданные();
	
	ПолноеИмя = МетаданныеДокумента.ПолноеИмя();
	
	СтрокаНеограниченнойДлинны = Новый ОписаниеТипов("Строка", , , , Новый КвалификаторыСтроки(0));
	
	РеквизитыДокумента = Новый Структура;
	РеквизитыДокумента.Вставить("Дата");
	Для каждого Реквизит Из МетаданныеДокумента.Реквизиты Цикл
		Если СтрНайти(Реквизит.Имя, "Удалить") = 1 Тогда
			Продолжить;
		КонецЕсли;
		Если Реквизит.Тип = СтрокаНеограниченнойДлинны Тогда
			Продолжить;
		КонецЕсли;
		Если РеквизитыИсключения.Свойство(Реквизит.Имя) Тогда
			Продолжить;
		КонецЕсли;
		РеквизитыДокумента.Вставить(Реквизит.Имя);
	КонецЦикла;
	
	ТабличныеЧастиДокумента = Новый Структура;
	Для каждого ТабличнаяЧасть Из МетаданныеДокумента.ТабличныеЧасти Цикл
		Если СтрНайти(ТабличнаяЧасть.Имя, "Удалить") = 1 Тогда
			Продолжить;
		КонецЕсли;
		Если ТабличныеЧастиИсключения.Свойство(ТабличнаяЧасть.Имя) Тогда
			Продолжить;
		КонецЕсли;
		РеквизитыТабличнойЧасти = Новый Структура;
		Для каждого Реквизит Из ТабличнаяЧасть.Реквизиты Цикл
			Если Реквизит.Тип = СтрокаНеограниченнойДлинны Тогда
				Продолжить;
			КонецЕсли; 
			РеквизитыТабличнойЧасти.Вставить(Реквизит.Имя);
		КонецЦикла;
		ТабличныеЧастиДокумента.Вставить(ТабличнаяЧасть.Имя, РеквизитыТабличнойЧасти);
	КонецЦикла;
	
	ТекстЗапроса= "ВЫБРАТЬ
		|	Таблица.Проведен КАК Проведен";
		ШаблонРеквизит = ",
		|	Таблица.%1 КАК %1";
	Для каждого Реквизит Из РеквизитыДокумента Цикл
		ТекстЗапроса = ТекстЗапроса + СтрШаблон(ШаблонРеквизит, Реквизит.Ключ); 
	КонецЦикла;
	
	ШаблонПоместить = "
	|ИЗ
	|	%1 КАК Таблица
	|ГДЕ
	|	Таблица.Ссылка = &Ссылка
	|";
	ТекстЗапроса = ТекстЗапроса + СтрШаблон(ШаблонПоместить, ПолноеИмя);
	
	Запрос = Новый Запрос;
	Запрос.Текст = ТекстЗапроса;
	Запрос.УстановитьПараметр("Ссылка", Объект.Ссылка); 
	
	Выборка = Запрос.Выполнить().Выбрать();
	Выборка.Следующий(); 
	
	ТаблицаИзмененныхРеквизитов = Новый ТаблицаЗначений;
	ТаблицаИзмененныхРеквизитов.Колонки.Добавить("Имя");
	ТаблицаИзмененныхРеквизитов.Колонки.Добавить("НовоеЗначение");
	ТаблицаИзмененныхРеквизитов.Колонки.Добавить("СтароеЗначение");
	Для каждого Реквизит Из РеквизитыДокумента Цикл
		Если Выборка[Реквизит.Ключ] <> Объект[Реквизит.Ключ] Тогда
			НоваяСтрока = ТаблицаИзмененныхРеквизитов.Добавить();
			НоваяСтрока.Имя = Реквизит.Ключ;
			НоваяСтрока.НовоеЗначение = Объект[Реквизит.Ключ];
			НоваяСтрока.СтароеЗначение = Выборка[Реквизит.Ключ];
		КонецЕсли;
	КонецЦикла;
	
	Если ТаблицаИзмененныхРеквизитов.Количество() > 0 Тогда
		Результат.Вставить("Реквизиты", ТаблицаИзмененныхРеквизитов);
	КонецЕсли;
	
	Для каждого ТабличнаяЧасть Из ТабличныеЧастиДокумента Цикл
		
		ТекстЗапроса = "ВЫБРАТЬ
		|	Таблица.НомерСтроки КАК НомерСтроки";
		ШаблонРеквизит = ",
		|	Таблица.%1 КАК %1";
		Для каждого Реквизит Из ТабличнаяЧасть.Значение Цикл
			ТекстЗапроса = ТекстЗапроса + СтрШаблон(ШаблонРеквизит, Реквизит.Ключ);
		КонецЦикла;
		
		ШаблонПоместить = "
		|ПОМЕСТИТЬ НоваяТаблица%1
		|ИЗ
		|	&%1 КАК Таблица
		|;
		|
		|////////////////////////////
		|";
		ТекстЗапроса = ТекстЗапроса + СтрШаблон(ШаблонПоместить, ТабличнаяЧасть.Ключ);
		
		ТекстОбъединенияНовая =
		"ВЫБРАТЬ
		|	Таблица.НомерСтроки КАК НомерСтроки";
		
		ТекстОбъединенияСтарая =
		"ВЫБРАТЬ
		|	-Таблица.НомерСтроки КАК НомерСтроки";
		
		ШаблонРеквизит = ",
		|	Таблица.%1 КАК %1";
		Для каждого Реквизит Из ТабличнаяЧасть.Значение Цикл
			ТекстОбъединенияНовая  = ТекстОбъединенияНовая + СтрШаблон(ШаблонРеквизит, Реквизит.Ключ);
			ТекстОбъединенияСтарая = ТекстОбъединенияСтарая + СтрШаблон(ШаблонРеквизит, Реквизит.Ключ);
		КонецЦикла;
		
		ШаблонИзНовая = "
		|ИЗ
		|	НоваяТаблица%1 КАК Таблица";
		ТекстОбъединенияНовая = ТекстОбъединенияНовая + СтрШаблон(ШаблонИзНовая, ТабличнаяЧасть.Ключ);
		
		ШаблонИзСтарая = "
		|ИЗ
		|	%1.%2 КАК Таблица
		|ГДЕ
		|	Таблица.Ссылка = &Ссылка";
		ТекстОбъединенияСтарая = ТекстОбъединенияСтарая + СтрШаблон(ШаблонИзСтарая, ПолноеИмя, ТабличнаяЧасть.Ключ);
		
		ТекстЗапроса = ТекстЗапроса + 
		"ВЫБРАТЬ
		|	СУММА(ВложенныйЗапрос.НомерСтроки) КАК НомерСтроки";
		ШаблонРеквизит = ",
		|	ВложенныйЗапрос.%1 КАК %1";
		Для каждого Реквизит Из ТабличнаяЧасть.Значение Цикл
			ТекстЗапроса  = ТекстЗапроса + СтрШаблон(ШаблонРеквизит, Реквизит.Ключ);
		КонецЦикла;
		ТекстЗапроса = ТекстЗапроса + "
		|ИЗ 
		|(" 
		+ Символы.ПС + ТекстОбъединенияНовая 
		+ Символы.ПС + " ОБЪЕДИНИТЬ ВСЕ "
		+ Символы.ПС + ТекстОбъединенияСтарая + ") КАК ВложенныйЗапрос
		|
		|СГРУППИРОВАТЬ ПО";
		
		ШаблонСгруппировать = "
		|	ВложенныйЗапрос.%1,";
		Для каждого Реквизит Из ТабличнаяЧасть.Значение Цикл
			ТекстЗапроса  = ТекстЗапроса + СтрШаблон(ШаблонСгруппировать, Реквизит.Ключ);
		КонецЦикла;
		ТекстЗапроса = ТекстЗапроса + "ИСТИНА
		|ИМЕЮЩИЕ 
		|	СУММА(ВложенныйЗапрос.НомерСтроки) <> 0";
		
		Запрос = Новый Запрос;
		Запрос.Текст = ТекстЗапроса;
		Запрос.УстановитьПараметр("Ссылка", Объект.Ссылка);
		Запрос.УстановитьПараметр(ТабличнаяЧасть.Ключ, Объект[ТабличнаяЧасть.Ключ]);
		
		РезультатЗапроса = Запрос.Выполнить();
		Если НЕ РезультатЗапроса.Пустой() Тогда
			Если НЕ Результат.Свойство("ТабличныеЧасти") Тогда
				Результат.Вставить("ТабличныеЧасти", Новый Структура);
			КонецЕсли;
			Результат.ТабличныеЧасти.Вставить(ТабличнаяЧасть.Ключ, РезультатЗапроса.Выгрузить());
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#Область ПроцедурыИФункцииДляПолученияПредставленияДанных

// Возвращает строковое представление документа для отображения в сообщениях.
//
// Параметры:
//	Ссылка - ссылка на документ
//	Номер - номер документа
//	Дата - дата документа
//
Функция ПолучитьПредставлениеДокумента(Ссылка, Номер, Дата) Экспорт
	
	Возврат
		Ссылка.Метаданные().Синоним
		+ ?(ЗначениеЗаполнено(Номер), " " + Номер, "")
		+ ?(ЗначениеЗаполнено(Дата), " " + НСтр("ru='от'") + " " + Формат(Дата,"ДЛФ=D"), "");
	
КонецФункции

#КонецОбласти

#Область ПрочиеПроцедурыИФункции

// Возвращает метаданные объекта по полному имени объекта метаданных
//
// Не обрабатываются точки маршрутов бизнес-процессов
//
// Параметры:
//  ПолноеИмя    - Строка, полное имя объекта метаданных,
//                 например, "Справочник.Организации".
//
// Возвращаемое значение:
//  КоллекцияОбъектовМетаданных
// 
Функция МетаданныеОбъектаПоПолномуИмени(ПолноеИмя) Экспорт
	
	ЧастиИмени = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ПолноеИмя, ".");
	
	КлассОМ = ЧастиИмени[0];
	ИмяОМ   = ЧастиИмени[1];
	
	Если      ВРег(КлассОМ) = "ПЛАНОБМЕНА" Тогда
		Возврат Метаданные.ПланыОбмена[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "СПРАВОЧНИК" Тогда
		Возврат Метаданные.Справочники[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ДОКУМЕНТ" Тогда
		Возврат Метаданные.Документы[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ЖУРНАЛДОКУМЕНТОВ" Тогда
		Возврат Метаданные.ЖурналыДокументов[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ПЕРЕЧИСЛЕНИЕ" Тогда
		Возврат Метаданные.Перечисления[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ОТЧЕТ" Тогда
		Возврат Метаданные.Отчеты[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ОБРАБОТКА" Тогда
		Возврат Метаданные.Обработки[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ПЛАНВИДОВХАРАКТЕРИСТИК" Тогда
		Возврат Метаданные.ПланыВидовХарактеристик[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ПЛАНСЧЕТОВ" Тогда
		Возврат Метаданные.ПланыСчетов[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ПЛАНВИДОВРАСЧЕТА" Тогда
		Возврат Метаданные.ПланЫВидовРасчета[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "РЕГИСТРСВЕДЕНИЙ" Тогда
		Возврат Метаданные.РегистрыСведений[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "РЕГИСТРНАКОПЛЕНИЯ" Тогда
		Возврат Метаданные.РегистрыНакопления[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "РЕГИСТРБУХГАЛТЕРИИ" Тогда
		Возврат Метаданные.РегистрыБухгалтерии[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "РЕГИСТРРАСЧЕТА" Тогда
		Возврат Метаданные.РегистрыРасчета[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "БИЗНЕСПРОЦЕСС" Тогда
		Возврат Метаданные.БизнесПроцессы[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ЗАДАЧА" Тогда
		Возврат Метаданные.Задачи[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "КОНСТАНТА" Тогда
		Возврат Метаданные.Константы[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ПОСЛЕДОВАТЕЛЬНОСТЬ" Тогда
		Возврат Метаданные.Последовательности[ИмяОМ];
		
	Иначе
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru='Неизвестный тип объекта метаданных (%1)'"), КлассОМ);
	КонецЕсли;
	
КонецФункции

// Возвращает массив с уникальными значениями из колонки таблицы
//
// Параметры:
//  Таблица		 - ТаблицаЗначений, ТабличнаяЧасть, ДанныеФормыСтруктура 
//  ИмяКолонки	 - Строка 
// 
// Возвращаемое значение:
// 	Массив 
//
Функция УникальныеЗначенияИзКолонкиТаблицы(Таблица, ИмяКолонки) Экспорт
	
	Если ТипЗнч(Таблица) = Тип("ТаблицаЗначений") Тогда
		ОбрабатываемаяТаблица = Таблица.Скопировать(,ИмяКолонки);
	Иначе
		ОбрабатываемаяТаблица = Таблица.Выгрузить(,ИмяКолонки);
	КонецЕсли;
		
	ОбрабатываемаяТаблица.Свернуть(ИмяКолонки);
	Возврат ОбрабатываемаяТаблица.ВыгрузитьКолонку(0);
	
КонецФункции // СвернутьТаблицуЗначенийПоРеквизиту()

// Удаляет указанные строки из таблицы значений.
// 
// Параметры:
//	Таблица - ТаблицаЗначений - обрабатываемая таблица
//	Строки  - Массив(элементы - СтрокаТаблицыЗначений) - массив удаляемых строк.
//
Процедура УдалитьСтрокиТаблицыЗначений(Таблица, Строки) Экспорт
	
	Для Каждого СтрокаТаблицы Из Строки Цикл
		Таблица.Удалить(СтрокаТаблицы);
	КонецЦикла;
	
КонецПроцедуры

// Удаляет строки из таблицы значений с учетом переданного отбора.
// 
// Параметры:
//	Таблица 			  - ТаблицаЗначений - обрабатываемая таблица
//	СтруктураПоиска 	  - Структура - структура поиска строк, см. описание метода НайтиСтроки() таблицы значений
//	УдалятьПопавшиеВОтбор - Булево - если указать Ложь, то будут удалены все строки, не входящие в отбор.
//
Процедура НайтиИУдалитьСтрокиТаблицыЗначений(Таблица, СтруктураПоиска, УдалятьПопавшиеВОтбор = Истина) Экспорт
	
	Строки = Таблица.НайтиСтроки(СтруктураПоиска);
	
	Если НЕ УдалятьПопавшиеВОтбор Тогда
		
		Если Строки.Количество() = Таблица.Количество() Тогда
			Возврат; // нечего удалять
		ИначеЕсли Строки.Количество() = 0 Тогда
			Таблица.Очистить();
		Иначе
			
			УдаляемыеСтроки = Новый Массив;
			
			Для Каждого СтрокаТаблицы Из Таблица Цикл
				
				Если Строки.Найти(СтрокаТаблицы) = Неопределено Тогда
					УдаляемыеСтроки.Добавить(СтрокаТаблицы); // строка не входит в переданный отбор
				КонецЕсли;
				
			КонецЦикла;
			
			УдалитьСтрокиТаблицыЗначений(Таблица, УдаляемыеСтроки);
			
		КонецЕсли;
		
	Иначе
		
		Если Строки.Количество() = 0 Тогда
			Возврат; // нечего удалять
		ИначеЕсли Строки.Количество() = Таблица.Количество() Тогда
			Таблица.Очистить();
		Иначе
			УдалитьСтрокиТаблицыЗначений(Таблица, Строки);
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

// Функция раскладывает переданный массив ссылок в соответствие по типам этих ссылок.
//
//	Параметры:
//		МассивСсылок - Массив - массив ссылок на объекты информационной базы
//  Возвращаемое значение:
//		Соответствие:
//			Ключ - полное имя типа ссылки
//	        Значение - массив ссылок этого типа.
//
Функция СоответствиеМассивовПоТипамОбъектов(МассивСсылок) Экспорт
	
	СоответствиеТипов = Новый Соответствие;
	
	Для Каждого Объект Из МассивСсылок Цикл
		
		ТипОбъекта = Объект.Метаданные().ПолноеИмя();
		ТекущийТипОбъекта = СоответствиеТипов.Получить(ТипОбъекта);
		
		Если ТекущийТипОбъекта = Неопределено Тогда
			СоответствиеТипов.Вставить(ТипОбъекта, Новый Массив);
			ТекущийТипОбъекта = СоответствиеТипов.Получить(ТипОбъекта);
		КонецЕсли;
		ТекущийТипОбъекта.Добавить(Объект);
		
	КонецЦикла;
	
	Возврат СоответствиеТипов;
	
КонецФункции

// Возвращает разницу между двумя датами (в днях)
//
// Параметры
//  ДатаНачала 		- Дата - начальная дата периода
//  ДатаОкончания	- Дата - конечная дата периода.
//
// Возвращаемое значение:
//   Число	 - количество дней между двумя датами.
//
Функция РазностьДат(ДатаНачала, ДатаОкончания, Периодичность) Экспорт
	
	СекундВМинуте = 60;
	МинутВЧасе = 60;
	ЧасовВДне = 24;
	
	Если Периодичность = Перечисления.Периодичность.Год Тогда
		Возврат Год(ДатаОкончания) - Год(ДатаНачала);
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.Полугодие Тогда
		Возврат ?(Месяц(ДатаОкончания)>6, 2, 1) - ?(Месяц(ДатаНачала)>6, 2, 1) + 2*(Год(ДатаОкончания) - Год(ДатаНачала));
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.Квартал Тогда
		Возврат Цел(Месяц(НачалоКвартала(ДатаОкончания))/3) - Цел(Месяц(НачалоКвартала(ДатаНачала))/3) + 4*(Год(ДатаОкончания) - Год(ДатаНачала));
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.Месяц Тогда
		Возврат Месяц(ДатаОкончания) - Месяц(ДатаНачала) + 12*(Год(ДатаОкончания) - Год(ДатаНачала));
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.Декада Тогда
		Возврат Цел((ДатаОкончания - ДатаНачала)/(10 * СекундВМинуте*МинутВЧасе*ЧасовВДне));
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.Неделя Тогда
		Возврат Цел((НачалоНедели(ДатаОкончания) - НачалоНедели(ДатаНачала))/(7 * СекундВМинуте*МинутВЧасе*ЧасовВДне));
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.День Тогда
		Возврат (ДатаОкончания - ДатаНачала)/(СекундВМинуте*МинутВЧасе*ЧасовВДне);
		
	КонецЕсли;
	
КонецФункции

// Возвращает ключ коллекции, имеющий указанное значение.
//
Функция КлючКоллекцииПоЗначению(Коллекция, Значение) Экспорт
	
	Для Каждого КлючИЗначение Из Коллекция Цикл
		Если КлючИЗначение.Значение = Значение Тогда
			Возврат КлючИЗначение.Ключ;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Неопределено;
	
КонецФункции

// Возвращает коллекцию, в которой ключи и значения поменяны местами.
//
Функция ПоменятьКлючИЗначениеКоллекции(Коллекция) Экспорт
	
	Если ТипЗнч(Коллекция) = Тип("Структура") ИЛИ ТипЗнч(Коллекция) = Тип("ФиксированнаяСтруктура") Тогда
		НоваяКоллекция = Новый Структура;
	ИначеЕсли ТипЗнч(Коллекция) = Тип("Соответствие") ИЛИ ТипЗнч(Коллекция) = Тип("ФиксированноеСоответствие") Тогда
		НоваяКоллекция = Новый Соответствие;
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
	Для Каждого КлючИЗначение Из Коллекция Цикл
		НоваяКоллекция.Вставить(КлючИЗначение.Значение, КлючИЗначение.Ключ);
	КонецЦикла;
	
	Если ТипЗнч(Коллекция) = Тип("ФиксированнаяСтруктура") Тогда
		НоваяКоллекция = Новый ФиксированнаяСтруктура(НоваяКоллекция);
	ИначеЕсли ТипЗнч(Коллекция) = Тип("ФиксированноеСоответствие") Тогда
		НоваяКоллекция = Новый ФиксированноеСоответствие(НоваяКоллекция);
	КонецЕсли;
	
	Возврат НоваяКоллекция;
	
КонецФункции

// Возвращает описание типов по переданному типу
// 
// Параметры:
//	Тип - Тип - тип значения
//
// Возвращаемое значение:
//	ОписаниеТипов - созданное на основании переданного типа описание типов.
//
Функция ОписаниеТиповПоТипу(Тип) Экспорт
	МассивТипов = Новый Массив;
	МассивТипов.Добавить(Тип);
	
	ОписаниеТипов = Новый ОписаниеТипов(МассивТипов);
	
	Возврат ОписаниеТипов;
КонецФункции

// Возвращает таблицу значений на основании массива структур
// 
// Параметры:
//	МассивСтруктур - МассивСтруктур - массив структур, которые будут преобразованы в таблиц значений.
//										Свойства структуры первого элемента массива определяют состав колонок результирующей таблицы.
//
// Возвращаемое значение:
//	ТаблицаЗначений - таблица значений, созданная из массива структур.
// 
Функция МассивВТаблицуЗначений(МассивСтруктур) Экспорт
	Таблица = Новый ТаблицаЗначений;
	// Создадим колонки по первой структуре массива
	Если ТипЗнч(МассивСтруктур) = Тип("Массив")
		И МассивСтруктур.Количество() <> 0 Тогда
		ПерваяСтруктура = МассивСтруктур[0];
		Для Каждого Свойство Из ПерваяСтруктура Цикл 
			Таблица.Колонки.Добавить(Свойство.Ключ, ОписаниеТиповПоТипу(ТипЗнч(Свойство.Значение)));
		КонецЦикла;
		
		Для Каждого Структура Из МассивСтруктур Цикл 
			НоваяСтрока = Таблица.Добавить();
			ЗаполнитьЗначенияСвойств(НоваяСтрока, Структура);
		КонецЦикла;
	КонецЕсли;
	
	Возврат Таблица;
КонецФункции

// Возвращает метаданные объекта по полному имени объекта метаданных
//
// Параметры:
//  ПолноеИмя - Строка - Полный путь к метаданным реквизита как в дереве метаданных.
//                       Пример: "Документы.ПоступлениеБезналичныхДенежныхСредств.ТабличныеЧасти.РасшифровкаПлатежа.Реквизиты.Заказ"
//                               "РегистрыНакопления.ДвиженияКонтрагентДоходыРасходы.Измерения.ОбъектРасчетов".
//
// Возвращаемое значение:
//  ОбъектМетаданных,КоллекцияОбъектовМетаданных.
//
Функция МетаданныеПоИмени(МетаданныеСтрокой) Экспорт
	
	Возврат СвойствоМетаданных(Метаданные, СтрРазделить(МетаданныеСтрокой, "."));
	
КонецФункции

Функция СвойствоМетаданных(МетаданныеОбъекта, ЧастиИмени, Индекс = 0)
	
	Имя = ЧастиИмени[Индекс];
	Свойство = МетаданныеОбъекта[Имя];
	Если Индекс < ЧастиИмени.ВГраница() Тогда
		Свойство = СвойствоМетаданных(Свойство, ЧастиИмени, Индекс+1);
	КонецЕсли;
	Возврат Свойство;
	
КонецФункции

// Возвращает структуру с ключами, соответствующими колонкам таблицы значений.
// Значения в структуре заполняются значениями полей из переданной строки таблицы.
//
// Параметры:
//	ТекущаяСтрока - СтрокаТаблицыЗначений
//
// Возвращаемое значение:
//	Структура
//
Функция ПреобразоватьСтрокуТаблицыВСтруктуру(ТекущаяСтрока) Экспорт
	
	Результат = Новый Структура;
	
	Для Каждого Колонка Из ТекущаяСтрока.Владелец().Колонки Цикл
		Результат.Вставить(Колонка.Имя, ТекущаяСтрока[Колонка.Имя]);
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Устанавливает параметры запроса из переданной структуры.
//
// Параметры:
//	Запрос - Запрос - запрос, параметры которого надо установить
//	ПараметрыЗапроса - Структура - структура с устанавливаемыми параметрами запроса.
//
Процедура УстановитьПараметрыЗапроса(Запрос, ПараметрыЗапроса) Экспорт
	
	Если НЕ ЗначениеЗаполнено(ПараметрыЗапроса) Тогда
		Возврат;
	КонецЕсли;
	
	Для Каждого КлючИЗначение Из ПараметрыЗапроса Цикл
		Запрос.УстановитьПараметр(КлючИЗначение.Ключ, КлючИЗначение.Значение);
	КонецЦикла;
	
КонецПроцедуры

// Свернуть табличную часть объекта
// По умолчанию все числовые колонки попадают в колонки суммирования. Те числовые колонки,
// которые должны попасть в колонки группировки, нужно перечислить в параметре КолонкиГруппировок.
// Нечисловые колонки перечислять в КолонкиГруппировки не нужно.
// 
// Параметры:
//  Объект			   - ДокументОбъект, СправочникОбъект, ОбработкаОбъект, ПланВидовХарактеристикОбъект, ПланОбменаОбъект 
//							- любой объект, содержащий табличную часть 
//  ИмяТЧ			   - Строка - имя табличной части, которую нужно свернуть
//  КолонкиГруппировок - Массив, Строка - массив строк с именами числовых колонок или строка с именами через запятую,
//  						которые нужно включить в колонки группировки, а не суммирования
//
Процедура СвернутьТабличнуюЧасть(Объект, ИмяТЧ, Знач КолонкиГруппировок = Неопределено) Экспорт
	
	Если КолонкиГруппировок = Неопределено Тогда
		КолонкиГруппировок = Новый Массив;
	ИначеЕсли ТипЗнч(КолонкиГруппировок) = Тип("Строка") Тогда
		КолонкиГруппировок = СтрРазделить(КолонкиГруппировок, ",", Ложь);
	КонецЕсли;
	
	КолонкиСуммирования = Новый Массив;
	
	МетаданныеДокумента = Объект.Метаданные();
	
	Для Каждого Колонка из МетаданныеДокумента.ТабличныеЧасти[ИмяТЧ].Реквизиты Цикл
		Если ТипЗнч(Колонка.Тип.ПривестиЗначение()) = Тип("Число") Тогда
			Если КолонкиГруппировок.Найти(Колонка.Имя)  = Неопределено Тогда
				КолонкиСуммирования.Добавить(Колонка.Имя);
			КонецЕсли;
		Иначе
			КолонкиГруппировок.Добавить(Колонка.Имя);	
		КонецЕсли;
	КонецЦикла;
	
	Объект[ИмяТЧ].Свернуть(СтрСоединить(КолонкиГруппировок, ","), СтрСоединить(КолонкиСуммирования,","));
	
КонецПроцедуры

// Сворачивает таблицу значение с возможностью сохранением порядка строк
// В случаи, когда параметр КолонкиСуммирования не указан все числовые колонки попадают в колонки суммирования.
// Те числовые колонки, которые должны попасть в колонки группировки, нужно перечислить в параметре КолонкиГруппировок.
// Нечисловые колонки перечислять в КолонкиГруппировки не нужно.
// При сохранении порядка строк колонки, которые не участвуют в сворачивании, не удаляются и остаются заполненными
// значением первой найденной строки в разрезе колонок группировки
// 
// Параметры:
//  Таблица			    - ТаблицаЗначений              - Таблица сворачивания
//  КолонкиГруппировок  - Строка, Массив, Неопределено - Колонки группировки таблицы
//  КолонкиСуммирования - Строка, Массив, Неопределено - Колонки сворачивания таблицы
//  СохранитьПорядок    - Булево                       - Признак сохранения порядка строк
//
Процедура СвернутьТаблицуЗначений(Таблица, Знач КолонкиГруппировок = Неопределено, Знач КолонкиСуммирования = Неопределено, СохранитьПорядок = Ложь) Экспорт
	
	Если КолонкиСуммирования = Неопределено Тогда
		
		Если КолонкиГруппировок = Неопределено Тогда
			КолонкиГруппировок = Новый Массив;
		ИначеЕсли ТипЗнч(КолонкиГруппировок) = Тип("Строка") Тогда
			КолонкиГруппировок = СтрРазделить(КолонкиГруппировок, ",", Ложь);
		КонецЕсли;
		
		КолонкиСуммирования = Новый Массив;
		
		Для Каждого Колонка из Таблица.Колонки Цикл
			Если ТипЗнч(Колонка.ТипЗначения.ПривестиЗначение()) = Тип("Число") Тогда
				Если КолонкиГруппировок.Найти(Колонка.Имя) = Неопределено Тогда
					КолонкиСуммирования.Добавить(Колонка.Имя);
				КонецЕсли;
			Иначе
				КолонкиГруппировок.Добавить(Колонка.Имя);	
			КонецЕсли;
		КонецЦикла;	
		
		КолонкиГруппировок  = СтрСоединить(КолонкиГруппировок , ",");
		КолонкиСуммирования = СтрСоединить(КолонкиСуммирования, ",");
		
	ИначеЕсли КолонкиГруппировок = Неопределено Тогда	
		
		Если ТипЗнч(КолонкиСуммирования) = Тип("Строка") Тогда
			КолонкиСуммирования = СтрРазделить(КолонкиСуммирования, ",", Ложь);
		КонецЕсли;
		
		КолонкиГруппировок = Новый Массив;
		
		Для Каждого Колонка из Таблица.Колонки Цикл
			Если КолонкиСуммирования.Найти(Колонка.Имя) = Неопределено Тогда
				КолонкиГруппировок.Добавить(Колонка.Имя);
			КонецЕсли;	
		КонецЦикла;
		
		КолонкиГруппировок  = СтрСоединить(КолонкиГруппировок , ",");
		КолонкиСуммирования = СтрСоединить(КолонкиСуммирования, ",");
		
	Иначе	
		
		Если ТипЗнч(КолонкиГруппировок) = Тип("Массив") Тогда
			КолонкиГруппировок = СтрСоединить(КолонкиГруппировок, ",");	
		КонецЕсли;	
		
		Если ТипЗнч(КолонкиСуммирования) = Тип("Массив") Тогда
			КолонкиСуммирования = СтрСоединить(КолонкиСуммирования, ",");	
		КонецЕсли;	
		
	КонецЕсли;
	
	
	Если СохранитьПорядок Тогда
		
		МассивКолонокСуммирования = СтрРазделить(КолонкиСуммирования, ",");
		
		Таблица.Индексы.Добавить(КолонкиГруппировок);
		
		ИндексСтроки    = 0;
		КоличествоСтрок = Таблица.Количество();
		СтруктураОтбора = Новый Структура(КолонкиГруппировок);
		
		Пока КоличествоСтрок > 0 Цикл
			
			СтрокаГруппировки = Таблица[ИндексСтроки];
			ЗаполнитьЗначенияСвойств(СтруктураОтбора, СтрокаГруппировки);
			
			МассивСтрок = Таблица.НайтиСтроки(СтруктураОтбора);
			ИндексНайденнойСтроки = МассивСтрок.ВГраница();
			Пока ИндексНайденнойСтроки > 0 Цикл
				
				НайденнаяСтрока = МассивСтрок[ИндексНайденнойСтроки];
				
				Для каждого КолонкаСуммирования Из МассивКолонокСуммирования Цикл
					СтрокаГруппировки[КолонкаСуммирования] = СтрокаГруппировки[КолонкаСуммирования] 
															 + НайденнаяСтрока[КолонкаСуммирования];  
				КонецЦикла;
				
				Таблица.Удалить(НайденнаяСтрока);
				
				КоличествоСтрок       = КоличествоСтрок - 1;
				ИндексНайденнойСтроки = ИндексНайденнойСтроки - 1;
				
			КонецЦикла;	
			
			КоличествоСтрок = КоличествоСтрок - 1;
			ИндексСтроки    = ИндексСтроки + 1;
			
		КонецЦикла;
	
	Иначе
		
		Таблица.Свернуть(КолонкиГруппировок, КолонкиСуммирования);
		
	КонецЕсли;	
	
КонецПроцедуры

#Область МетодыРаботыСЗапросом

// Формирует пакет запросов и возвращает результат каждого запроса
//
// Параметры:
//	Запрос			- Запрос - запрос, параметры которого предварительно установлены.
//	ТекстыЗапроса	- СписокЗначений - в списке перечислены тексты запросов и их имена.
//	ОбходРезультата - ОбходРезультатаЗапроса - вариант обхода результата запроса.
//	ДобавитьРазделитель - Булево - добавлять разделитель между запросами из ТекстыЗапроса
//	УничтожитьСозданныеВременныеТаблицы - Булево - добавить уничтожение временных таблиц, создаваемых в ТекстыЗапроса
//										Для уничтожения таблице должно быть присвоено имя в ТекстыЗапроса.
//
// Возвращаемое значение:
//   Структура   - структура в которую помещены полученные таблицы.
//
Функция ВыгрузитьРезультатыЗапроса(Запрос,
								 	ТекстыЗапроса,
									ОбходРезультата = Неопределено,
									ДобавитьРазделитель = Ложь,
									УничтожитьСозданныеВременныеТаблицы = Ложь) Экспорт

	Таблицы = Новый Структура;
	
	// Инициализация варианта обхода результата запроса.
	Если ОбходРезультата = Неопределено Тогда
		ОбходРезультата = ОбходРезультатаЗапроса.Прямой;
	КонецЕсли;
	
	МассивТекстовЗапросов 	 = Новый Массив;
	МассивУничтожаемыхТаблиц = Новый Массив;
	
	// Формирование текст запроса.
	Для Каждого ТекстЗапроса Из ТекстыЗапроса Цикл
		
		Если ЗначениеЗаполнено(ТекстЗапроса.Представление) Тогда
			МассивТекстовЗапросов.Добавить("// " + ТекстЗапроса.Представление);
		КонецЕсли; 
		
		МассивТекстовЗапросов.Добавить(ТекстЗапроса.Значение + ?(ДобавитьРазделитель, РазделительЗапросовВПакете(), ""));
		
		Если УничтожитьСозданныеВременныеТаблицы
		 И ЗначениеЗаполнено(ТекстЗапроса.Представление)
		 И СтрНайти(ВРег(ТекстЗапроса.Значение), "ПОМЕСТИТЬ") <> 0 Тогда
			МассивУничтожаемыхТаблиц.Добавить(ТекстЗапроса.Представление);
		КонецЕсли;
		
	КонецЦикла;
	
	Для Каждого ИмяУдаляемойТаблицы Из МассивУничтожаемыхТаблиц Цикл
		МассивТекстовЗапросов.Добавить("УНИЧТОЖИТЬ " + ИмяУдаляемойТаблицы + РазделительЗапросовВПакете());
	КонецЦикла;
	
	Если МассивТекстовЗапросов.Количество() > 0 Тогда
		
		// Выполнение запроса.
		Запрос.Текст = СтрСоединить(МассивТекстовЗапросов, Символы.ПС);
		Результаты = Запрос.ВыполнитьПакет();

		// Помещение результатов запроса в таблицы.
		Для Каждого ТекстЗапроса Из ТекстыЗапроса Цикл
			ИмяТаблицы = ТекстЗапроса.Представление;
			Если НЕ ПустаяСтрока(ИмяТаблицы) Тогда // имя таблицы
				Результат = Результаты[ТекстыЗапроса.Индекс(ТекстЗапроса)];
				Если Результат <> Неопределено Тогда
					ТаблицаЗапроса = Результат.Выгрузить(ОбходРезультата);
					Если Таблицы.Свойство(ТекстЗапроса.Представление) Тогда
						ОбъединитьТаблицыРезультатовЗапроса(ТаблицаЗапроса, Таблицы[ИмяТаблицы]);
					Иначе
						Таблицы.Вставить(ИмяТаблицы, ТаблицаЗапроса);
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;

		КонецЦикла;
		
	КонецЕсли;
	
	Возврат Таблицы;
	
КонецФункции

// Выполняет добавление строк из таблицы источника в таблицу приемник с предварительной проверкой:
// - типов колонок
// - состава колонок
// При необходимости выполняет корректировку таблицы-приемника.
//
Процедура ОбъединитьТаблицыРезультатовЗапроса(ТаблицаИсточник, ТаблицаПриемник)
	
	КолонкиДляОбъединенияТипов = Новый Структура();
	КолонкиДляДобавления = Новый Структура();
	Для каждого КолонкаИсточника Из ТаблицаИсточник.Колонки Цикл
		КолонкаПриемника = ТаблицаПриемник.Колонки.Найти(КолонкаИсточника.Имя);
		Если КолонкаПриемника <> Неопределено Тогда
			
			КолонкаИсточникаТипы = КолонкаИсточника.ТипЗначения.Типы();
			ОтсутствующиеТипы = Новый Массив;
			
			// Проверим наличие типов входящих в описание источника в приемнике.
			// Если отсутствуют - объединим описания типов, пересоздадим колонки таблицы.
			Для каждого ТипКолонкиИсточника Из КолонкаИсточникаТипы Цикл
				Если НЕ КолонкаПриемника.ТипЗначения.СодержитТип(ТипКолонкиИсточника) Тогда
					ОтсутствующиеТипы.Добавить(ТипКолонкиИсточника);
				КонецЕсли;
			КонецЦикла;
			
			// Сравним квалификаторы примитивных типов источника и приемника.
			// Если в описании типов источника квалификаторы "более общие", то возьмем их.
			ИзменитьКвалификаторыЧисла = Ложь;
			КвалификаторыЧисла = КолонкаПриемника.ТипЗначения.КвалификаторыЧисла;
			Если КолонкаИсточника.ТипЗначения.СодержитТип(Тип("Число")) И КолонкаПриемника.ТипЗначения.СодержитТип(Тип("Число")) Тогда
				КвалификаторыЧислаИсточника = КолонкаИсточника.ТипЗначения.КвалификаторыЧисла;  
				Если КвалификаторыЧислаИсточника.Разрядность > КвалификаторыЧисла.Разрядность Тогда
					Разрядность = КвалификаторыЧислаИсточника.Разрядность;
					ИзменитьКвалификаторЧисла = Истина;
				Иначе
					Разрядность = КвалификаторыЧисла.Разрядность;
				КонецЕсли;
				Если КвалификаторыЧислаИсточника.РазрядностьДробнойЧасти > КвалификаторыЧисла.РазрядностьДробнойЧасти Тогда
					РазрядностьДробнойЧасти = КвалификаторыЧислаИсточника.РазрядностьДробнойЧасти;
					ИзменитьКвалификаторыЧисла = Истина;
				Иначе
					РазрядностьДробнойЧасти = КвалификаторыЧисла.РазрядностьДробнойЧасти;
				КонецЕсли;
				Если КвалификаторыЧислаИсточника.ДопустимыйЗнак <> КвалификаторыЧисла.ДопустимыйЗнак Тогда
					Знак = ДопустимыйЗнак.Любой;
					ИзменитьКвалификаторыЧисла = Истина;
				Иначе
					Знак = КвалификаторыЧисла.ДопустимыйЗнак;
				КонецЕсли;
				Если ИзменитьКвалификаторыЧисла Тогда
					КвалификаторыЧисла = Новый КвалификаторыЧисла(Разрядность, РазрядностьДробнойЧасти, Знак);
				КонецЕсли;
			КонецЕсли;
			
			ИзменитьКвалификаторыСтроки = Ложь;
			КвалификаторыСтроки = КолонкаПриемника.ТипЗначения.КвалификаторыСтроки;
			Если КолонкаИсточника.ТипЗначения.СодержитТип(Тип("Строка")) 
				 И КолонкаПриемника.ТипЗначения.СодержитТип(Тип("Строка")) Тогда
				КвалификаторыСтрокиИсточника = КолонкаИсточника.ТипЗначения.КвалификаторыСтроки;
				Если КвалификаторыСтроки.Длина <> 0 И КвалификаторыСтрокиИсточника.Длина > КвалификаторыСтроки.Длина Тогда
					ИзменитьКвалификаторЧисла = Истина;
					КвалификаторыСтроки = Новый КвалификаторыСтроки(КвалификаторыСтрокиИсточника.Длина);
				КонецЕсли; 
			КонецЕсли;
			
			ИзменитьКвалификаторыДаты = Ложь;
			КвалификаторыДаты = КолонкаПриемника.ТипЗначения.КвалификаторыДаты;
			Если КолонкаИсточника.ТипЗначения.СодержитТип(Тип("Дата")) 
				 И КолонкаПриемника.ТипЗначения.СодержитТип(Тип("Дата")) Тогда
				КвалификаторыДатыИсточника = КолонкаИсточника.ТипЗначения.КвалификаторыДаты;
				Если КвалификаторыДатыИсточника.ЧастиДаты <> КвалификаторыДаты.ЧастиДаты Тогда
					ИзменитьКвалификаторыДаты = Истина;
					КвалификаторыДаты = Новый КвалификаторыДаты(ЧастиДаты.ДатаВремя);
				КонецЕсли; 
			КонецЕсли;
			
			ИзменитьКвалификаторыДвоичныхДанных = Ложь;
			КвалификаторыДвоичныхДанных = КолонкаПриемника.ТипЗначения.КвалификаторыДвоичныхДанных;
			Если КолонкаИсточника.ТипЗначения.СодержитТип(Тип("ДвоичныеДанные")) 
				 И КолонкаПриемника.ТипЗначения.СодержитТип(Тип("ДвоичныеДанные")) Тогда
				КвалификаторыДвоичныхДанныхИсточника = КолонкаИсточника.ТипЗначения.КвалификаторыДвоичныхДанных;
				Если КвалификаторыДвоичныхДанных.Длина <> 0 И КвалификаторыДвоичныхДанныхИсточника.Длина > КвалификаторыДвоичныхДанных.Длина Тогда
					ИзменитьКвалификаторыДвоичныхДанных = Истина;
					КвалификаторыДвоичныхДанных = Новый КвалификаторыДвоичныхДанных(КвалификаторыДвоичныхДанныхИсточника.Длина);
				КонецЕсли; 
			КонецЕсли;
			
			Если ОтсутствующиеТипы.Количество() > 0
				Или ИзменитьКвалификаторыЧисла 
				Или ИзменитьКвалификаторыСтроки 
				Или ИзменитьКвалификаторыДаты
				Или ИзменитьКвалификаторыДвоичныхДанных Тогда
				ОписаниеТиповОбъединение = Новый ОписаниеТипов(КолонкаПриемника.ТипЗначения, ОтсутствующиеТипы, , 
				                                               КвалификаторыЧисла, КвалификаторыСтроки, КвалификаторыДаты, КвалификаторыДвоичныхДанных);
				КолонкиДляОбъединенияТипов.Вставить(КолонкаПриемника.Имя, ОписаниеТиповОбъединение);
			КонецЕсли;
		Иначе
			КолонкиДляДобавления.Вставить(КолонкаИсточника.Имя, КолонкаИсточника.ТипЗначения)
		КонецЕсли;
	КонецЦикла;
	
	Для каждого Колонка Из КолонкиДляОбъединенияТипов Цикл
		ЗначенияВКолонке = ТаблицаПриемник.ВыгрузитьКолонку(Колонка.Ключ);
		ТаблицаПриемник.Колонки.Удалить(Колонка.Ключ);
		ТаблицаПриемник.Колонки.Добавить(Колонка.Ключ, Колонка.Значение);
		ТаблицаПриемник.ЗагрузитьКолонку(ЗначенияВКолонке, Колонка.Ключ);
	КонецЦикла;
	
	Для каждого Колонка Из КолонкиДляДобавления Цикл
		ТаблицаПриемник.Колонки.Добавить(Колонка.Ключ, Колонка.Значение);
	КонецЦикла;
	
	ДополнитьТаблицу(ТаблицаИсточник, ТаблицаПриемник);
	
КонецПроцедуры

// Дополняет таблицу значений - приемник данными из таблицы значений - источника.
// Типы ТаблицаЗначений, ДеревоЗначений, ТабличнаяЧасть не доступны на клиенте.
//
// Параметры:
//  ТаблицаИсточник - ТаблицаЗначений,
//                    ДеревоЗначений,
//                    ТабличнаяЧасть,
//                    ДанныеФормыКоллекция - таблица, из которой будут браться строки для заполнения;
//  ТаблицаПриемник - ТаблицаЗначений,
//                    ДеревоЗначений,
//                    ТабличнаяЧасть,
//                    ДанныеФормыКоллекция - таблица, в которую будут добавлены строки из таблицы-источника.
//
Процедура ДополнитьТаблицу(ТаблицаИсточник, ТаблицаПриемник) Экспорт
	
	Для Каждого СтрокаТаблицыИсточник Из ТаблицаИсточник Цикл
		
		ЗаполнитьЗначенияСвойств(ТаблицаПриемник.Добавить(), СтрокаТаблицыИсточник);
		
	КонецЦикла;
	
КонецПроцедуры

// Возвращает структуру границ оборотов по регистру
//
// Параметры:
//  ИмяРегистра - Строка - Имя регистра накопления.
//  Отборы      - Строка - Отборы виртуальной таблицы оборотов, для которой необходимо получить границы.
//  Параметры   - Структура - Параметры запроса для отборов виртуальной таблицы.
//
// Возвращаемое значение:
//  Структура - Структура границ со свойствами:
//  	* МинимальнаяДата - Дата - Начальная граница оборотов.
//  	* МаксимальнаяДата - Дата - Конечная граница оборотов.
//
Функция ГраницыОборотовРегистра(ИмяРегистра, Отборы, Параметры) Экспорт
	
	// Без отбора по умолчанию по полю Активность, т.к. по нему нет индекса,
	// из-за чего запрос может выполняться недопустимо долго.
	Запрос = Новый Запрос(СтрШаблон(
		"ВЫБРАТЬ
		|	МИНИМУМ(Таблица.Период)  КАК МинимальнаяДата,
		|	МАКСИМУМ(Таблица.Период) КАК МаксимальнаяДата
		|ИЗ
		|	РегистрНакопления.%1 КАК Таблица
		|ГДЕ
		|	%2", ИмяРегистра, ?(ПустаяСтрока(Отборы), "ИСТИНА", Отборы)));
	
	Для каждого Параметр Из Параметры Цикл
		Запрос.УстановитьПараметр(Параметр.Ключ, Параметр.Значение);
	КонецЦикла;
	
	УстановитьПривилегированныйРежим(Истина);
	Выборка = Запрос.Выполнить().Выбрать();
	УстановитьПривилегированныйРежим(Ложь);
	
	СтруктураГраниц = Новый Структура;
	Если Выборка.Следующий() И ЗначениеЗаполнено(Выборка.МинимальнаяДата) Тогда
		СтруктураГраниц.Вставить("МинимальнаяДата", Выборка.МинимальнаяДата);
		СтруктураГраниц.Вставить("МаксимальнаяДата", Выборка.МаксимальнаяДата);
	Иначе
		СтруктураГраниц.Вставить("МинимальнаяДата", '00010101');
		СтруктураГраниц.Вставить("МаксимальнаяДата", '39991231');
	КонецЕсли;
	
	Возврат СтруктураГраниц;
	
КонецФункции

// Возвращает строку для вставки между запросами, объединяемыми в пакет
// 
// Возвращаемое значение:
//  Строка 
//
Функция РазделительЗапросовВПакете() Экспорт
	
	Возврат "
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|";
	
КонецФункции

// Возвращает строку для вставки между текстами объединяемых запросов
// Параметры:
//	ТолькоУникальные - Булево - признак того, что необходимо выбирать только уникальные записи при объединении
//		значение по умолчанию - ЛОЖЬ.
// 
// Возвращаемое значение:
//  Строка 
//
Функция РазделительЗапросовВОбъединении(ТолькоУникальные = Ложь) Экспорт
	
	Если ТолькоУникальные Тогда
		Возврат "
		|
		|ОБЪЕДИНИТЬ
		|
		|";
	Иначе
		Возврат "
		|
		|ОБЪЕДИНИТЬ ВСЕ
		|
		|";
	КонецЕсли;
	
КонецФункции

//Добавляет настройку отбора для запросов в коллекцию 
//
// Параметры:
//  Отбор               - Соответствие - коллекция настроек отборов
//  ЛевоеЗначение       - Строка       - левое значение отбора в запросах
//  ПравоеЗначение      - Строка       - правое значение отбора в запросах
//  ВидСравненияЗапроса - Строка       - вид сравнения запроса, по умолчанию: "В"
//
Процедура ДобавитьЭлементОтбораВКоллекцию(Отбор, ЛевоеЗначение, ПравоеЗначение, ВидСравненияЗапроса = "") Экспорт
	
	ВидСравненияПравоеЗначение = Новый Структура;
	
	ВидСравненияПравоеЗначение.Вставить("ВидСравнения"  , 
		?(ЗначениеЗаполнено(ВидСравненияЗапроса), ВидСравненияЗапроса, "В"));
		
	ВидСравненияПравоеЗначение.Вставить("ПравоеЗначение", ПравоеЗначение);
		
	Отбор.Вставить(ЛевоеЗначение, ВидСравненияПравоеЗначение);            
	
КонецПроцедуры

#КонецОбласти

#Область ПоискВТаблице

// Выполняет нумерацию строк таблицы значений. Для нумерации используется колонка ПорядковыйНомер.
// Если колонка с таким именем отсутствует в переданной таблице, то она будет добавлена.
//
// Параметры:
//  Таблица	- ТаблицаЗначений - таблица, строки которой будут пронумерованы.
//
Процедура ДобавитьВТаблицуПорядковыйНомерСтрок(Таблица) Экспорт
	
	ПронумероватьТаблицуЗначений(Таблица, "ПорядковыйНомер");
	
КонецПроцедуры

// Заполняет значение колонки ПорядковыйНомер в новой строке таблицы значений,
// строки которой пронумерованы (см. процедуру ДобавитьВТаблицуПорядковыйНомерСтрок).
//
// Параметры:
//  Таблица		 - ТаблицаЗначений - таблица с пронумерованными строками.
//  НоваяСтрока	 - СтрокаТаблицыЗначений - строка в которой необходимо заполнить порядковый номер.
//
Процедура ЗаполнитьПорядковыйНомерВНовойСтроке(Таблица, НоваяСтрока) Экспорт
	
	НоваяСтрока.ПорядковыйНомер = Таблица.Количество() + 1;
	
КонецПроцедуры

// Осуществляет поиск строк в таблице значений с сохранением их порядка.
//
// Параметры:
//  Таблица				 - ТаблицаЗначений - таблица в которой необходимо выполнить поиск.
//  УсловиеПоиска		 - Структура - условие поиска строк.
//  СтрокиПронумерованы	 - Булево - Истина, если строки таблицы были предварительно пронумерованы
//		(см. процедуру ДобавитьВТаблицуПорядковыйНомерСтрок).
// 
// Возвращаемое значение:
//  Массив - найденные строки.
//
Функция НайтиСтрокиССохранениемПорядка(Таблица, УсловиеПоиска, СтрокиПронумерованы = Ложь) Экспорт
	
	НайденныеСтроки = Таблица.НайтиСтроки(УсловиеПоиска);
	
	Если НайденныеСтроки.Количество() > 1 Тогда
		
		Если СтрокиПронумерованы Тогда
			
			Результат = УпорядочитьПронумерованныеСтроки(Таблица, НайденныеСтроки);
			
		Иначе
			
			Результат = УпорядочитьНеПронумерованныеСтроки(Таблица, НайденныеСтроки);
			
		КонецЕсли;
		
	Иначе
		
		Результат = НайденныеСтроки;
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Функция УпорядочитьПронумерованныеСтроки(Таблица, МассивСтрок)
	
	СтрокиУпорядочены = МассивПронумерованныхСтрокУпорядочен(МассивСтрок);
	
	Если СтрокиУпорядочены Тогда
		
		Результат = МассивСтрок;
		
	Иначе
		
		ТаблицаСортировки = Новый ТаблицаЗначений;
		ТаблицаСортировки.Колонки.Добавить("Строка", Новый ОписаниеТипов("СтрокаТаблицыЗначений"));
		ТаблицаСортировки.Колонки.Добавить("ПорядковыйНомер", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла));
		
		Для Индекс = 0 По МассивСтрок.ВГраница() Цикл
			
			Строка = МассивСтрок[Индекс];
			
			НоваяСтрока = ТаблицаСортировки.Добавить();
			НоваяСтрока.Строка = Строка;
			НоваяСтрока.ПорядковыйНомер = Строка.ПорядковыйНомер;
			
		КонецЦикла;
		
		ТаблицаСортировки.Сортировать("ПорядковыйНомер ВОЗР");
		
		Результат = Новый Массив;
		Для Индекс = 0 По ТаблицаСортировки.Количество()-1 Цикл
			
			Результат.Добавить(ТаблицаСортировки[Индекс].Строка);
			
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Функция МассивПронумерованныхСтрокУпорядочен(МассивСтрок)
	
	Результат = Истина;
	
	МаксИндекс = МассивСтрок.ВГраница();
	
	ПредыдущаяСтрока = МассивСтрок[МаксИндекс];
	Для Сч = 1 По МаксИндекс Цикл
		
		ТекущаяСтрока = МассивСтрок[МаксИндекс-сч];
		Если ТекущаяСтрока.ПорядковыйНомер > ПредыдущаяСтрока.ПорядковыйНомер Тогда
			Результат = Ложь;
			Прервать;
		КонецЕсли;
		
		ПредыдущаяСтрока = ТекущаяСтрока;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция УпорядочитьНеПронумерованныеСтроки(Таблица, МассивСтрок)
	
	ТаблицаИндексов = ИндексыНеПронумерованныхСтрок(Таблица, МассивСтрок);
	СтрокиУпорядочены = ТаблицаИндексовУпорядочена(ТаблицаИндексов);
	
	Если СтрокиУпорядочены Тогда
		
		Результат = МассивСтрок;
		
	Иначе
		
		ТаблицаИндексов.Сортировать("ИндексТаблицы ВОЗР");
		
		Результат = Новый Массив;
		Для Индекс = 0 По ТаблицаИндексов.Количество()-1 Цикл
			
			Результат.Добавить(ТаблицаИндексов[Индекс].Строка);
			
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Функция ИндексыНеПронумерованныхСтрок(Таблица, МассивСтрок)
	
	Результат = Новый ТаблицаЗначений;
	Результат.Колонки.Добавить("Строка", Новый ОписаниеТипов("СтрокаТаблицыЗначений"));
	Результат.Колонки.Добавить("ИндексТаблицы", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла));
	
	Для Индекс = 0 По МассивСтрок.ВГраница() Цикл
		
		Строка = МассивСтрок[Индекс];
		
		НоваяСтрока = Результат.Добавить();
		НоваяСтрока.Строка = Строка;
		НоваяСтрока.ИндексТаблицы = Таблица.Индекс(Строка);
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция ТаблицаИндексовУпорядочена(ТаблицаИндексов)
	
	Результат = Истина;
	
	ПредыдущаяСтрока = ТаблицаИндексов[0];
	Для Индекс = 1 По ТаблицаИндексов.Количество()-1 Цикл
		
		ТекущаяСтрока = ТаблицаИндексов[Индекс];
		Если ТекущаяСтрока.ИндексТаблицы < ПредыдущаяСтрока.ИндексТаблицы Тогда
			Результат = Ложь;
			Прервать;
		КонецЕсли;
		
		ПредыдущаяСтрока = ТекущаяСтрока;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#КонецОбласти

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Процедура ЗаписатьПлощадкуПоОбъектам(Источник)
	
	ТипыОбъектовПлощадки = УБХУправлениеНСИПовтИсп.ПолучитьТипыОбъектовПлощадки(); 
	
	Для Каждого СтрокаТЧ Из Источник.ОбъектыПлощадки Цикл
		Если НЕ ТипыОбъектовПлощадки.Найти(ТипЗнч(СтрокаТЧ.ОбъектПлощадки)) = Неопределено Тогда
			ОбъектПлощадки = СтрокаТЧ.ОбъектПлощадки.ПолучитьОбъект();
			ОбъектПлощадки.ОбменДанными.Загрузка = Истина;
			ОбъектПлощадки.Площадка = Источник.Ссылка;
			ОбъектПлощадки.Записать();
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

Процедура ЗаписатьОбъектыПлощадки(Источник)
	
	Блокировка = Новый БлокировкаДанных;
	ЭлементБлокировки = Блокировка.Добавить("РегистрСведений.УБХОбъектыПлощадок");
	ЭлементБлокировки.УстановитьЗначение("Площадка", Источник.Ссылка);
	ЭлементБлокировки.Режим = РежимБлокировкиДанных.Исключительный;
	Блокировка.Заблокировать();
 
	НаборЗаписей = РегистрыСведений.УБХОбъектыПлощадок.СоздатьНаборЗаписей();
	НаборЗаписей.Отбор.Площадка.Установить(Источник.Ссылка);
	НаборЗаписей.Прочитать();
	
	ТаблицаОбъектыПлощадки = Источник.ОбъектыПлощадки.Выгрузить();
	ТаблицаОбъектыПлощадки.Колонки.Добавить("Площадка", Новый ОписаниеТипов("СправочникСсылка.УБХПлощадки"));
	ТаблицаОбъектыПлощадки.ЗаполнитьЗначения(Источник.Ссылка, "Площадка");
	
	НаборЗаписей.Загрузить(ТаблицаОбъектыПлощадки);
	НаборЗаписей.Записать();

КонецПроцедуры

#КонецОбласти

// Процедура проверяет переданный параметр, если он не соответствует значению, 
// то присваивает ему указанное значение.
//
// Параметры:
//  Параметр - параметр, значение которого проверяется и заполняется.
//  Значение - значение для заполнения пустого параметра.
//
Процедура УстановитьНовоеЗначение(Параметр, Значение) Экспорт
	
	Если Параметр <> Значение Тогда
		Параметр = Значение;
	КонецЕсли;
	
КонецПроцедуры

Функция НачалоНеделиПоМесяцу(ДатаНачала) Экспорт
	
	Если День(ДатаНачала) < 7 Тогда
		Возврат ?(День(НачалоНедели(ДатаНачала))>День(ДатаНачала),НачалоМесяца(ДатаНачала),НачалоНедели(ДатаНачала));
	Иначе
		Возврат НачалоНедели(ДатаНачала);
	КонецЕсли;
	
КонецФункции // НачалоНеделиПоМесяцу

//Функция добавляет "ЧислоДней" к "Дата"
//
Функция ДобавитьДень(Дата, ЧислоДней) Экспорт
	
	Возврат Дата + ЧислоДней * 86400; // 86400 = 24*60*60 - число секунд в дне;
	
КонецФункции // () 

// Функция добавляет интервал к дате
//
// Параметры:
//	Периодичность (Перечисления.Периодичность)	- пнриодичность планирования по сценарию.
//	ДатаВПериоде (Дата)							- произвольная дата
//	Смещение (число)							- определяет направление и количество периодов, в котором сдвигается дата
//
// Возвращаемое значение:
//	Дата, отстоящая от исходной на заданное количество периодов 
//
Функция ДобавитьИнтервал(ДатаПериода,Периодичность,Смещение) Экспорт
	
	Если Смещение = 0 Тогда
		НоваяДатаПериода = ДатаПериода;
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.День Тогда
		НоваяДатаПериода = НачалоДня(ДатаПериода + Смещение*24*3600);
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.Неделя Тогда
		НоваяДатаПериода = НачалоНеделиПоМесяцу(ДатаПериода + Смещение*7*24*3600);
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.Декада Тогда
		НоваяДатаПериода = НачалоДекады(ДатаПериода + Смещение*11*24*3600);
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.Месяц Тогда
		НоваяДатаПериода = ДобавитьМесяц(ДатаПериода, Смещение);
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.Квартал Тогда
		НоваяДатаПериода = ДобавитьМесяц(ДатаПериода, Смещение*3);
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.Полугодие Тогда
		НоваяДатаПериода = ДобавитьМесяц(ДатаПериода, Смещение*6);
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.ДевятьМесяцев Тогда
		НоваяДатаПериода = ДобавитьМесяц(ДатаПериода, Смещение*9);
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.Год Тогда
		НоваяДатаПериода = ДобавитьМесяц(ДатаПериода, Смещение*12);
		
	Иначе
		НоваяДатаПериода=НачалоДня(ДатаПериода) + Смещение*24*3600;
		
	КонецЕсли;
	
	Возврат НоваяДатаПериода;
	
КонецФункции // ДобавитьИнтервал()

Функция НачалоДекады(ДатаНачала) Экспорт
	
	Если День(ДатаНачала) < 10 Тогда
		Возврат НачалоМесяца(ДатаНачала);
	ИначеЕсли День(ДатаНачала) < 20 Тогда
		Возврат ДобавитьДень(НачалоМесяца(ДатаНачала), 10);
	Иначе 
		Возврат ДобавитьДень(НачалоМесяца(ДатаНачала), 20);
	КонецЕсли;
	
КонецФункции // НачалоДекады()
