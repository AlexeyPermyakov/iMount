////////////////////////////////////////////////////////////////////////////////
// Серверный модуль для работы росреестром.
// Основное назначение:
//  - разбор файлов xml;
//	- выполнение функций получения информации на сайте росреестра.
//  
////////////////////////////////////////////////////////////////////////////////

#Область ПрограммныйИнтерфейс

#Область ПрограммныйИнтерфейсРаботаСXml

// Возвращает истину, если xml-файл корректен.
//
// Параметры:
//  ИмяФайлаНаСервере	 - Строка - имя файла, сохраненного на сервере.
// 
// Возвращаемое значение:
//   Булево - корректен ли документ.
//
Функция ПроверитьXmlНаКорректность(ИмяФайлаНаСервере) Экспорт
	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.ОткрытьФайл(ИмяФайлаНаСервере);
	Фабрика = Новый ФабрикаXDTO;
	
	Результат = Ложь;
	Попытка
		ОбъектXDTO = Фабрика.ПрочитатьXML(ЧтениеXML);
		Результат = Истина;
	Исключение
	КонецПопытки;
	
	ЧтениеXML.Закрыть();
	
	Возврат Результат;
КонецФункции

// Определяет тип документа по xml-файлу.
//
// Параметры:
//  ИмяФайлаНаСервере	 - Строка - имя файла, сохраненного на сервере.
// 
// Возвращаемое значение:
//   ПеречислениеСсылка.гисТипыКадастровыхДокументов - тип документа.
//
Функция ПолучитьТипДокумента(ИмяФайлаНаСервере) Экспорт
	ТипДокумента = Неопределено;
	
	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.ОткрытьФайл(ИмяФайлаНаСервере);
	МожноЗакрывать = Ложь;
	Пока Не МожноЗакрывать И ЧтениеXML.Прочитать() Цикл
		Если ЧтениеXML.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
			МожноЗакрывать = Истина;
			
			ИмяУзла = ЧтениеXML.Имя;
			
			ВерсияXMLСхемы = ПолучитьВерсиюXMLСхемы(ЧтениеXML.URIПространстваИмен);
			Если ИмяУзла = "KVZU" Тогда
				Если ВерсияXMLСхемы = "7" Тогда
					ТипДокумента = Перечисления.гисТипыКадастровыхДокументов.КадастроваяВыписка7;
				Иначе
					ТипДокумента = Перечисления.гисТипыКадастровыхДокументов.КадастроваяВыписка6;	
				КонецЕсли;
			ИначеЕсли ИмяУзла = "KPZU" Тогда
				Если ВерсияXMLСхемы = "6" Тогда
					ТипДокумента = Перечисления.гисТипыКадастровыхДокументов.КадастровыйПаспорт6;
				Иначе
					ТипДокумента = Перечисления.гисТипыКадастровыхДокументов.КадастровыйПаспорт5;
				КонецЕсли;
			ИначеЕсли ИмяУзла = "KPT" Тогда
				Если ВерсияXMLСхемы = "10" Тогда
					ТипДокумента = Перечисления.гисТипыКадастровыхДокументов.КадастровыйПлан10;
				Иначе 
					ТипДокумента = Перечисления.гисТипыКадастровыхДокументов.КадастровыйПлан9;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	ЧтениеXML.Закрыть();
	
	Возврат ТипДокумента;
КонецФункции

// Возвращает дату xml-файла, когда его сформировали.
//
// Параметры:
//  ИмяФайлаНаСервере	 - Строка - имя файла, сохраненного на сервере.
// 
// Возвращаемое значение:
//   Дата - дата сформированного xml-файла.
//
Функция ПолучитьДатуДокумента(ИмяФайлаНаСервере) Экспорт
	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.ОткрытьФайл(ИмяФайлаНаСервере);
	
	Фабрика = Новый ФабрикаXDTO;
	ОбъектXDTO = Фабрика.ПрочитатьXML(ЧтениеXML);
	
	ДатаДокумента = ПолучитьДатуДокументаПоОбъекту(ОбъектXDTO);
	
	ЧтениеXML.Закрыть();
	Возврат ДатаДокумента;
КонецФункции

// Возвращает системы координат, используемые в xml-файле.
//
// Параметры:
//  ИмяФайлаНаСервере	 - Строка - имя файла, сохраненного на сервере;
//  ТипДокумента		 - ПеречислениеСсылка.гисТипыКадастровыхДокументов - тип документа.
// 
// Возвращаемое значение:
//   Массив - системы координат - структура с полями:
//		Ид		- Строка - идентификатор системы в xml-файле;
//		Имя		- Строка - название системы в xml-файле;
//		Ссылка	- СправочникСсылка.гисПараметрыПереводаВWgs84 - соответствующие параметры перевода.
//
Функция ПолучитьСистемыКоординат(ИмяФайлаНаСервере, Знач ТипДокумента) Экспорт
	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.ОткрытьФайл(ИмяФайлаНаСервере);
	
	Фабрика = Новый ФабрикаXDTO;
	ОбъектXDTO = Фабрика.ПрочитатьXML(ЧтениеXML);
	
	МассивСистемКоординат = Новый Массив;
	// выписка 6, паспорт 5
	Если ТипДокумента = Перечисления.гисТипыКадастровыхДокументов.КадастроваяВыписка6 Или ТипДокумента = Перечисления.гисТипыКадастровыхДокументов.КадастроваяВыписка7 Или
		ТипДокумента = Перечисления.гисТипыКадастровыхДокументов.КадастровыйПаспорт5 Или ТипДокумента = Перечисления.гисТипыКадастровыхДокументов.КадастровыйПаспорт6 Тогда
		
		CoordSystems = ПолучитьЗначениеСвойстваРекурсивно(ОбъектXDTO, "CoordSystems.CoordSystem");
		Если CoordSystems <> "" Тогда
			ДобавитьСистемыКоординат(CoordSystems, МассивСистемКоординат);
		КонецЕсли;
	// кпт 9
	ИначеЕсли ТипДокумента = Перечисления.гисТипыКадастровыхДокументов.КадастровыйПлан9 Или ТипДокумента = Перечисления.гисТипыКадастровыхДокументов.КадастровыйПлан10 Тогда
		CadastralBlock = ПолучитьЗначениеСвойстваРекурсивно(ОбъектXDTO, "CadastralBlocks.CadastralBlock");
		
		Если ТипЗнч(CadastralBlock) = Тип("СписокXDTO") Тогда
			Для Каждого КадастровыйКвартал Из CadastralBlock Цикл
				CoordSystems = ПолучитьЗначениеСвойстваРекурсивно(КадастровыйКвартал, "CoordSystems.CoordSystem");
				Если CoordSystems <> "" Тогда
					ДобавитьСистемыКоординат(CoordSystems, МассивСистемКоординат);
				КонецЕсли;
			КонецЦикла;
		ИначеЕсли ТипЗнч(CadastralBlock) = Тип("ОбъектXDTO") Тогда
			CoordSystems = ПолучитьЗначениеСвойстваРекурсивно(CadastralBlock, "CoordSystems.CoordSystem");
			Если CoordSystems <> "" Тогда
				ДобавитьСистемыКоординат(CoordSystems, МассивСистемКоординат);
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	ЧтениеXML.Закрыть();
	Возврат МассивСистемКоординат;
КонецФункции

// Заполняет в массив данные по земельным участкам из xml-файла.
//
// Параметры:
//  ИмяФайлаНаСервере	 - Строка - название файла, сохраненного на сервере;
//  ТипДокумента		 - ПеречислениеСсылка.гисТипыКадастровыхДокументов - тип кадастрового документа;
//  МассивДанныхXml		 - Массив - данные земельных участков;
//  ИмяИсходногоФайла	 - Строка - название файла, как он назывался на клиенте, нужно для вывода ошибки.
// 
// Возвращаемое значение:
//   Булево - Истина если данные успешно загружены, ложь в противном случае.
//
Функция ЗаполнитьМассивДанныхЗемельныеУчастки(ИмяФайлаНаСервере, Знач ТипДокумента, МассивДанныхXml, ИмяИсходногоФайла = Неопределено) Экспорт
	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.ОткрытьФайл(ИмяФайлаНаСервере);
	
	Фабрика = Новый ФабрикаXDTO;
	ОбъектXDTO = Фабрика.ПрочитатьXML(ЧтениеXML);
	
	МассивДанныхXml = Новый Массив;
	Результат = ЗаполнитьТабличнуюЧастьЗемельныеУчастки(ОбъектXDTO, ТипДокумента, МассивДанныхXml, ИмяИсходногоФайла);
	
	ЧтениеXML.Закрыть();
	Возврат Результат;
КонецФункции

#КонецОбласти

#Область ПрограммныйИнтерфейсРосреестр

// TODO: эту функцию не удаётся реализовать текущими средствами Росреестра
// Возвращает информацию по кадастровым кварталам, которые есть в Росреестре,
// начало кадастрового номера которых совпадает с заданным.
//
// Параметры:
//  КадастровыйНомер - Строка - начало кадастрового номера кадастрового квартала.
// 
// Возвращаемое значение:
//  Массив - элементы массива - Структура:
//	 	КадастровыйНомер - строка - кадастровый номер кадастрового квартала.
//
Функция ПолучитьКварталы(КадастровыйНомер) Экспорт
	МассивДанных = Новый Массив;
	
	Http = Новый HTTPСоединение("maps.rosreestr.ru");
	Скрипт = "arcgis/rest/services/Cadastre/CadastreSelected/MapServer/2/query";
	Запрос = "/" + Скрипт + "?where=PKK_ID%20like%20'" + СтрЗаменить(СтрЗаменить(КадастровыйНомер, ":", ""), "%", "%25") + "'&f=json&outFields=CAD_NUM&returnGeometry=false";
	
	Ошибка = Ложь;
	
	Попытка
		ЗапросКСерверу = Новый HTTPЗапрос(Запрос);
		Ответ = Http.Получить(ЗапросКСерверу);
		Если Ответ.КодСостояния = 200 Тогда
			Текст = Ответ.ПолучитьТелоКакСтроку();
		Иначе
			ТекстОшибки = "Сервер ответил ошибкой!" + Символы.ПС + Ответ.КодСостояния;
			Ошибка = Истина;
		КонецЕсли;
	Исключение
		ТекстОшибки = "Сервер не отвечает на запрос! Данные не загружены!";
		Ошибка = Истина;
	КонецПопытки;
	
	Если Не Ошибка Тогда
		Попытка
			Json = гисРаботаСJson.ПрочитатьНативно(Текст);
			Если Json.Свойство("error") Тогда
				ТекстОшибки = "Ошибка!";
				Попытка
					ТекстОшибки = ТекстОшибки + Символы.ПС + Json.error.message;
				Исключение
				КонецПопытки;
				Ошибка = Истина;
			ИначеЕсли Не Json.Свойство("features") Тогда
				ТекстОшибки = "Для кадастрового номера " + КадастровыйНомер + " не найдены данные на Росреестре!";
				Ошибка = Истина;
			КонецЕсли;	
		Исключение
			ТекстОшибки = "Неизвестная ошибка!" + Символы.ПС + Текст;
			Ошибка = Истина;
		КонецПопытки;
	КонецЕсли;
	
	Если Не Ошибка Тогда
		Для Каждого feature Из Json.features Цикл
			СтрокаДанных = Новый Структура("КадастровыйНомер", feature.attributes.CAD_NUM);
			МассивДанных.Добавить(СтрокаДанных);
		КонецЦикла;
	Иначе
		ОбщегоНазначения.СообщитьПользователю(ТекстОшибки);
	КонецЕсли;
	
	Возврат МассивДанных;
КонецФункции

// TODO: эту функцию не удаётся реализовать текущими средствами Росреестра
// Возвращает информацию по всем участкам, которые есть в Росреестре,
// начало кадастрового номера которых совпадает с заданным.
//
// Параметры:
//  КадастровыйНомер - Строка - начало кадастрового номера земельного участка.
// 
// Возвращаемое значение:
//  Массив - элементы массива - Структура:
//		КадастровыйНомер- Строка - кадастровый номер земельного участка;
//		Статус			- СправочникСсылка.гисСтатусыКадастровыхУчастков - статус земельного участка;
//		КатегорияЗемель - СправочникСсылка.гисКатегорииЗемель - категория земель участка;
//		ВидИспользования- СправочникСсылка.гисВидыРазрешенногоИспользования - вид использования участка.
//
Функция ПолучитьЗУВсе(КадастровыйНомер) Экспорт
	МассивДанных = Новый Массив;
	
	Http = Новый HTTPСоединение("maps.rosreestr.ru");
	Скрипт = "arcgis/rest/services/Cadastre/CadastreSelected/MapServer/exts/GKNServiceExtension/online/parcel/find";
	Запрос = "/" + Скрипт + "?cadNum=" + СтрЗаменить(КадастровыйНомер, "%", "%25") + "&f=json";
	
	НомерСтраницы = 1;
	КоличествоВсего = Неопределено;
	МаксимальноеКоличествоПопыток = 3;
	НомерПопытки = 1;
	
	Пока КоличествоВсего = Неопределено Или (НомерСтраницы - 1) * 20 < КоличествоВсего Цикл
		Ошибка = Ложь;
		
		Попытка
			ЗапросСтраницы = Запрос + "&page=" + НомерСтраницы;
			
			ЗапросКСерверу = Новый HTTPЗапрос(ЗапросСтраницы);
			Ответ = Http.Получить(ЗапросКСерверу);
			Если Ответ.КодСостояния = 200 Тогда
				Текст = Ответ.ПолучитьТелоКакСтроку();
			Иначе
				ТекстОшибки = "Сервер ответил ошибкой!" + Символы.ПС + Ответ.КодСостояния;
				Ошибка = Истина;
			КонецЕсли;
		Исключение
			ТекстОшибки = "Сервер не отвечает на запрос! Данные не загружены!";
			Ошибка = Истина;
		КонецПопытки;	
		
		Если Не Ошибка Тогда 
			Попытка
				Json = гисРаботаСJson.ПрочитатьНативно(Текст);
				Если Json.Свойство("error") Тогда
					ТекстОшибки = "Ошибка!";
					Попытка
						ТекстОшибки = ТекстОшибки + Символы.ПС + Json.error.message;
					Исключение
					КонецПопытки;
					Ошибка = Истина;
				ИначеЕсли Не Json.Свойство("features") Тогда
					ТекстОшибки = "Для кадастрового номера " + КадастровыйНомер + " не найдены данные на Росреестре!";
					Ошибка = Истина;
				КонецЕсли;	
			Исключение
				ТекстОшибки = "Неизвестная ошибка!" + Символы.ПС + Текст;
				Ошибка = Истина;
			КонецПопытки;
		КонецЕсли;
		
		Если Не Ошибка Тогда
			Для Каждого feature Из Json.features Цикл
				СтрокаДанных = Новый Структура("КадастровыйНомер", feature.attributes.PARCEL_CN);
				СтрокаДанных.Вставить("Статус", Справочники.гисСтатусыКадастровыхУчастков.НайтиПоКоду(feature.attributes.STATE_CODE));
				СтрокаДанных.Вставить("КатегорияЗемель", Справочники.гисКатегорииЗемель.НайтиПоКоду(feature.attributes.CATEGORY_TYPE));
				СтрокаДанных.Вставить("ВидИспользования", Справочники.гисВидыРазрешенногоИспользования.НайтиПоКоду(feature.attributes.UTIL_CODE));
				МассивДанных.Добавить(СтрокаДанных);
			КонецЦикла;
			
			КоличествоВсего = Json.featuresCount;
			НомерСтраницы = НомерСтраницы + 1;
			НомерПопытки = 1;
		Иначе
			Если НомерПопытки = МаксимальноеКоличествоПопыток Тогда
				Если НомерСтраницы = 1 Тогда
					ОбщегоНазначения.СообщитьПользователю("Сервер не доступен!");
					Возврат МассивДанных;
				КонецЕсли;
				ОбщегоНазначения.СообщитьПользователю(ТекстОшибки + Символы.ПС + "(страница " + НомерСтраницы + ")");
				НомерПопытки = 1;
				НомерСтраницы = НомерСтраницы + 1;
			Иначе
				НомерПопытки = НомерПопытки + 1;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Возврат МассивДанных;
КонецФункции


// Возвращает массив данных от росреестра по кадастровому номеру.
//
// Параметры:
//  КадастровыйНомер - Строка - кадастровый номер земельного участка.
// 
// Возвращаемое значение:
//   Массив - данные Росреестра.
//
Функция ЗаполнитьМассивДанныхИзРосреестра(КадастровыйНомер) Экспорт
	МассивДанных = Новый Массив;
	
	Попытка
		ОбъектПоиска = ПолучитьFeatures(КадастровыйНомер);
		ДанныеXml = ЗемельныеУчасткиПолучитьСтруктуруДанныхXml();
		ЗаполнитьДанныеXml(ДанныеXml, ОбъектПоиска);

		МассивДанных.Добавить(ДанныеXml);
	Исключение
		ОбщегоНазначения.СообщитьПользователю(ОписаниеОшибки());
	КонецПопытки;
	
	Возврат МассивДанных;
КонецФункции

// Возвращает земельные участки, найденные по кадастровому номеру на росреестре.
//
// Параметры:
//  КадастровыйНомер - Строка - кадастровый номер земельного участка.
// 
// Возвращаемое значение:
//   Массив - данные Росреестра.
//
Функция ПолучитьFeatures(Знач КадастровыйНомер) Экспорт
	Соединение = Новый HTTPСоединение("rosreestr.ru", , , , , 30, , );
	ЗапросИдентификатораОбъекта = "/api/online/fir_objects/" + КадастровыйНомер;
	Запрос = Новый HTTPЗапрос(ЗапросИдентификатораОбъекта);
	Ответ = Соединение.Получить(Запрос);
	Если Ответ.КодСостояния = 200 Тогда
		Текст = Ответ.ПолучитьТелоКакСтроку();
	Иначе
		ВызватьИсключение НСтр("ru = 'Сервер ответил ошибкой! Код HTTP: '") + Ответ.КодСостояния;
	КонецЕсли;
	
	Json = гисРаботаСJSON.ПрочитатьНативно(Текст);
	ЕстьДанные = Ложь;
	Если ТипЗНЧ(JSon) = Тип("Массив") И JSon.Количество() > 0 Тогда
		ЭлементJson = JSon[0];
		Если JSon[0].Свойство("objectId") Тогда
			ИдентификаторОбъекта = ЭлементJson.objectId;
			ЕстьДанные = Истина;
		КонецЕсли;
	КонецЕсли;
	
	Если Не ЕстьДанные Тогда
		ВызватьИсключение НСтр("ru = 'Для кадастрового номера '") + КадастровыйНомер + НСтр("ru = ' не найдены данные на РосРеестре!'");
	КонецЕсли;
	
	ЗапросДанные = "api/online/fir_object/" + ИдентификаторОбъекта;
	Запрос = Новый HTTPЗапрос(ЗапросДанные);
	Ответ = Соединение.Получить(Запрос);
	Если Ответ.КодСостояния = 200 Тогда
		Текст = Ответ.ПолучитьТелоКакСтроку();
	Иначе
		ВызватьИсключение НСтр("ru = 'Сервер ответил ошибкой! Код HTTP: '") + Ответ.КодСостояния;
	КонецЕсли;
	
	Json = гисРаботаСJSON.ПрочитатьНативно(Текст);
	
	Возврат Json;
КонецФункции

// Возвращает bbox, к которому можно приблизиться на карте.
//
// Параметры:
//  Границы	 - Структура - содержит поля:
//	 XMIN - Число - минимальная долгота;
//	 YMIN - Число - минимальная широта;
//	 XMAX - Число - максимальная долгота;
//	 YMAX - Число - максимальная широта.
//
// Возвращаемое значение:
//   Строка - json, bbox для отображения.
//
Функция СформироватьBbox(Границы) Экспорт
	extent = Новый Массив;
	extent.Добавить(Границы.xmin);
	extent.Добавить(Границы.ymin);
	extent.Добавить(Границы.xmax);
	extent.Добавить(Границы.ymax);
	
	bbox = Новый Структура("proj,extent", "EPSG:3857", extent);
	Возврат гисРаботаСJson.ЗаписатьНативно(bbox);
КонецФункции

#КонецОбласти

#Область ПрограммныйИнтерфейсСтруктурыДанных

// Возвращает структуру, в которой будут храниться данные о кадастровом земельном участке.
// 
// Возвращаемое значение:
//   Структура - структура данных о кадастровом земельном участке.
//
Функция ЗемельныеУчасткиПолучитьСтруктуруДанныхXml() Экспорт
	Структура = Новый Структура("КадастровыйНомер,ВидУчасткаКод,СтатусКод,ДатаПостановкиНаУчет,
		|ПредыдущийКадастровыйНомер,КатегорияЗемельКод,ВидИспользованияКод,
		|ВидИспользованияПоДокументу,Комментарий,ОКАТО,ОКТМО,Адрес,АдресЗначенияПолей,АдресЗначение,Площадь,КадастроваяСтоимость");
	Структура.Вставить("ПраваНаУчасток", Новый Массив);
	Структура.Вставить("Контуры", Новый Массив);
	
	Структура.ДатаПостановкиНаУчет = Дата("00010101");
	
	Возврат Структура;
КонецФункции

// Возвращает структуру, в которой будут храниться данные о правах на кадастровый земельный участок.
// 
// Возвращаемое значение:
//   Структура - структура данных о правах на кадастровый земельный участок.
//
Функция ЗемельныеУчасткиПолучитьСтруктуруДанныхПраваНаУчасток() Экспорт
	Структура = Новый Структура("ВидПраваКод,Комментарий,Период,НомерГРП,ЧислительДробиДоли,ЗнаменательДробиДоли,ПлощадьДоли,Документы,
								|ПравообладательИНН,ПравообладательНаименование,ПравообладательФамилия,ПравообладательИмя,
								|ПравообладательОтчество,ПравообладательСНИЛС,ПравообладательТип");
	Структура.Период = Дата("00010101");
	Возврат Структура;
КонецФункции

// Возвращает структуру, в которой будут храниться данные о документах на права на кадастровый земельный участок.
// 
// Возвращаемое значение:
//   Структура - структура данных о документах на права на кадастровый земельный участок.
//
Функция ЗемельныеУчасткиПолучитьСтруктуруДанныхПраваНаУчастокДокументы() Экспорт
	Структура = Новый Структура("CodeDocument,Name,Series,Number,Date,IssueOrgan,Desc");
	Структура.Date = Дата("00010101");
	Возврат Структура;
КонецФункции

// Возвращает структуру, в которой будут храниться данные о контурах кадастрового земельного участка.
// 
// Возвращаемое значение:
//   Структура - структура данных о контурах кадастрового земельного участка.
//
Функция ЗемельныеУчасткиПолучитьСтруктуруДанныхКонтуры() Экспорт
	Возврат Новый Структура("ПорядковыйНомер,КадастровыйНомер,Геометрия,СистемаКоординат")
КонецФункции

// Возвращает массив названий свойств типа "Дата" в json'e с данными о кадастровом земельном участке.
// Нужно, чтобы при преобразовании из json даты преобразовались корректно.
// 
// Возвращаемое значение:
//   Массив - названия имен свойств объекта с типом "Дата".
//
Функция ЗемельныеУчасткиПолучитьМассивСвойствДата() Экспорт
	Массив = Новый Массив;
	Массив.Добавить("ДатаПостановкиНаУчет");
	Массив.Добавить("Период");
	Возврат Массив;
КонецФункции

// Возвращает массив названий свойств типа "Дата" в json'e с данными о правах на кадастровый земельный участок.
// Нужно, чтобы при преобразовании из json даты преобразовались корректно.
// 
// Возвращаемое значение:
//   Массив - названия имен свойств объекта с типом "Дата".
//
Функция ЗемельныеУчасткиПолучитьМассивСвойствДатаПраваНаУчастокДокументы() Экспорт
	Массив = Новый Массив;
	Массив.Добавить("Date");
	Возврат Массив;	
КонецФункции

#КонецОбласти

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Функция ПолучитьВерсиюXMLСхемы(URIПространстваИмен)
	МассивПодстрок = СтрРазделить(URIПространстваИмен, "/", Истина);
	СтрВерсия = МассивПодстрок[МассивПодстрок.Количество()-1];	
	
	МассивВерсии = СтрРазделить(СтрВерсия, ".", Истина);
	Если МассивВерсии.Количество()>0 Тогда
		Возврат МассивВерсии[0];
	Иначе		
		Возврат 0;	
	КонецЕсли;
КонецФункции

#Область СлужебныеПроцедурыИФункцииПроцедурыИФункцииОбщегоНазначения

Функция ПолучитьЗначениеСвойства(СтруктураДанных, ИмяСвойства)
	НайденноеЗначение = "";
	Если СтруктураДанных.Свойства().Получить(ИмяСвойства) = Неопределено Тогда
		Возврат "";
	Иначе
		ЗначениеСвойства = СтруктураДанных[ИмяСвойства]; 
		Если ТипЗнч(ЗначениеСвойства) = Тип("Строка") Тогда
			Возврат СокрЛП(ЗначениеСвойства);
		Иначе
			Возврат ЗначениеСвойства;
		КонецЕсли;
	КонецЕсли;
	Возврат "";
КонецФункции

Функция ПолучитьЗначениеСвойстваРекурсивно(СтруктураДанных, ИмяСвойства)
	ПозицияТочки = Найти(ИмяСвойства, ".");
	Если ПозицияТочки = 0 Тогда
		Возврат ПолучитьЗначениеСвойства(СтруктураДанных, ИмяСвойства);
	Иначе
		ИмяВложеннойСтруктурыДанных = Лев(ИмяСвойства, ПозицияТочки - 1);
		ВложеннаяСтруктура = ПолучитьЗначениеСвойства(СтруктураДанных, ИмяВложеннойСтруктурыДанных);
		ИмяВложенногоСвойства = Сред(ИмяСвойства, ПозицияТочки + 1, СтрДлина(ИмяСвойства) - ПозицияТочки);
		Если ВложеннаяСтруктура = "" Тогда
			Возврат "";
		Иначе
			Возврат ПолучитьЗначениеСвойстваРекурсивно(ВложеннаяСтруктура, ИмяВложенногоСвойства);
		КонецЕсли;
	КонецЕсли;
КонецФункции

Функция ПолучитьДатуДокументаПоОбъекту(ОбъектXDTO)
	ДатаДокумента = Дата("00010101");
	
	ДатаВыдачи = ПолучитьЗначениеСвойстваРекурсивно(ОбъектXDTO, "CertificationDoc.Date");
	Если ДатаВыдачи <> "" Тогда
		ДатаДокумента = Дата(СтрЗаменить(ДатаВыдачи, "-", ""));
	КонецЕсли;
	
	Возврат ДатаДокумента;
КонецФункции

Процедура ДобавитьСистемуКоординат(CoordSystem, МассивСистемКоординат)
	ИдСистемы = ПолучитьЗначениеСвойстваРекурсивно(CoordSystem, "CsId");
	ИмяСистемы = ПолучитьЗначениеСвойстваРекурсивно(CoordSystem, "Name");
	МассивСистемКоординат.Добавить(Новый Структура("Ид,Имя,Ссылка", ИдСистемы, ИмяСистемы));
КонецПроцедуры

Процедура ДобавитьСистемыКоординат(CoordSystems, МассивСистемКоординат)
	Если ТипЗнч(CoordSystems) = Тип("СписокXDTO") Тогда
		Для Каждого CoordSystem Из CoordSystems Цикл
			ДобавитьСистемуКоординат(CoordSystem, МассивСистемКоординат);
		КонецЦикла;
	ИначеЕсли ТипЗнч(CoordSystems) = Тип("ОбъектXDTO") Тогда
		ДобавитьСистемуКоординат(CoordSystems, МассивСистемКоординат)
	КонецЕсли;
КонецПроцедуры

Функция ХешПредставления(Знач Представление, Знач ИгнорироватьЗнакНомера=Ложь)
	Результат = СтрЗаменить(Представление, Символы.ПС, "");
	Результат = СтрЗаменить(Результат, " ", "");
	Если ИгнорироватьЗнакНомера Тогда
		Результат = СтрЗаменить(Результат, "№", "");
	КонецЕсли;
	Возврат ВРег(Результат);
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункцииРаботаСГеометрией

Процедура КонтурыДобавитьТочки(Точки, SpatialElement, ТипДокумента, НомерКонтура = 1)
	ПредыдущийНомерТочки = 0;
	
	SpatialElements = ПолучитьЗначениеСвойстваРекурсивно(SpatialElement, "SpelementUnit");
	Если ТипЗнч(SpatialElements) = Тип("СписокXDTO") Тогда
		Для Каждого SpelementUnit Из SpatialElements Цикл
			Координаты = Новый Структура;
			Координаты.Вставить("X", Число(ПолучитьЗначениеСвойстваРекурсивно(SpelementUnit, "Ordinate.X")));
			Координаты.Вставить("Y", Число(ПолучитьЗначениеСвойстваРекурсивно(SpelementUnit, "Ordinate.Y")));
			
			НомерТочки = ПолучитьЗначениеСвойстваРекурсивно(SpelementUnit, "SuNmb");
			Если НомерТочки = "" Тогда
				НомерТочки = ПолучитьЗначениеСвойстваРекурсивно(SpelementUnit, "Ordinate.OrdNmb");
			КонецЕсли;
			Если НомерТочки = "" Тогда
				НомерТочки = ПредыдущийНомерТочки + 1;
			КонецЕсли;
			Точки.Вставить("НомерКонтура_" + НомерКонтура + "_Номер_" + НомерТочки, Координаты);
			
			ПредыдущийНомерТочки = НомерТочки;
		КонецЦикла;
	ИначеЕсли ТипЗнч(SpatialElements) = Тип("ОбъектXDTO") Тогда
		Координаты = Новый Структура;
		Координаты.Вставить("X", Число(ПолучитьЗначениеСвойстваРекурсивно(SpatialElements, "Ordinate.X")));
		Координаты.Вставить("Y", Число(ПолучитьЗначениеСвойстваРекурсивно(SpatialElements, "Ordinate.Y")));
		
		НомерТочки = ПолучитьЗначениеСвойстваРекурсивно(SpatialElements, "SuNmb");
		Если НомерТочки = "" Тогда
			НомерТочки = ПолучитьЗначениеСвойстваРекурсивно(SpatialElements, "Ordinate.OrdNmb");
		КонецЕсли;
		Если НомерТочки = "" Тогда
			НомерТочки = ПредыдущийНомерТочки + 1;
		КонецЕсли;
		Точки.Вставить("НомерКонтура_" + НомерКонтура + "_Номер_" + НомерТочки, Координаты);
		
		ПредыдущийНомерТочки = НомерТочки;
	КонецЕсли;
КонецПроцедуры
 
Процедура КонтурыДобавитьГраницы(Границы, Border)
	Point1 = ПолучитьЗначениеСвойстваРекурсивно(Border, "Point1");
	Point2 = ПолучитьЗначениеСвойстваРекурсивно(Border, "Point2");
	Если Point1 <> Point2 Тогда
		Граница = Новый Структура;
		Граница.Вставить("НомерКонтура", Число(ПолучитьЗначениеСвойстваРекурсивно(Border, "Spatial")));
		Граница.Вставить("Точка1", Point1);
		Граница.Вставить("Точка2", Point2);
		Границы.Добавить(Граница);
	КонецЕсли;
КонецПроцедуры

Функция КонтурыПолучитьКоординатыВНужномФормате(МассивКонтуров, ТипГеометрии)
	Координаты = Новый Массив;
	
	Если МассивКонтуров.Количество() = 1 Тогда
		Если ТипГеометрии = "LineString" Тогда
			Координаты = МассивКонтуров[0];
		ИначеЕсли ТипГеометрии = "Polygon" Тогда
			Координаты = МассивКонтуров;
		КонецЕсли;
	ИначеЕсли МассивКонтуров.Количество() > 1 Тогда
		Если ТипГеометрии = "LineString" Тогда
			// TODO - вообще неправильно
			ТипГеометрии = "Polygon";
			Координаты = МассивКонтуров;
		ИначеЕсли ТипГеометрии = "Polygon" Тогда
			Для Каждого Контур Из МассивКонтуров Цикл
				Координаты.Добавить(Контур);
			КонецЦикла;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Координаты;
КонецФункции

Функция КонтурыЗаполнитьКоординатыПоТочкамИГраницам(Точки, Границы, ТипГеометрии)
	ТаблицаГраниц = Новый ТаблицаЗначений;
	ТаблицаГраниц.Колонки.Добавить("НомерКонтура", Новый ОписаниеТипов("Число"));
	ТаблицаГраниц.Колонки.Добавить("Точка1", Новый ОписаниеТипов("Строка"));
	ТаблицаГраниц.Колонки.Добавить("Точка2", Новый ОписаниеТипов("Строка"));
	
	КоличествоКонтуров = 0;
	Для Каждого Граница Из Границы Цикл
		НоваяСтрока = ТаблицаГраниц.Добавить();
		НоваяСтрока.НомерКонтура = Граница.НомерКонтура;
		НоваяСтрока.Точка1 = Граница.Точка1;
		НоваяСтрока.Точка2 = Граница.Точка2;
		Если Граница.НомерКонтура > КоличествоКонтуров Тогда
			КоличествоКонтуров = Граница.НомерКонтура;
		КонецЕсли;
	КонецЦикла;
	
	ТипГеометрии = "";
	МассивКонтуров = Новый Массив;
	Для НомерКонтура = 1 По КоличествоКонтуров Цикл
		ГраницыКонтура = ТаблицаГраниц.НайтиСтроки(Новый Структура("НомерКонтура", НомерКонтура));
		Если ГраницыКонтура.Количество() = 0 Тогда
			Продолжить;
		КонецЕсли;
		
		Контур = Новый Массив;
		
		СледующаяСтрока = ГраницыКонтура[0];
		
		НачальнаяТочка = СледующаяСтрока.Точка1;
		КоординатыТочки = Новый Массив;
		КоординатыТочки.Добавить(Точки["НомерКонтура_" + НомерКонтура + "_Номер_" + НачальнаяТочка].X);
		КоординатыТочки.Добавить(Точки["НомерКонтура_" + НомерКонтура + "_Номер_" + НачальнаяТочка].Y);
		Контур.Добавить(КоординатыТочки);
		
		Точка2 = СледующаяСтрока.Точка2;
		КоординатыТочки = Новый Массив;
		КоординатыТочки.Добавить(Точки["НомерКонтура_" + НомерКонтура + "_Номер_" + Точка2].X);
		КоординатыТочки.Добавить(Точки["НомерКонтура_" + НомерКонтура + "_Номер_" + Точка2].Y);
		Контур.Добавить(КоординатыТочки);
		
		Пока НачальнаяТочка <> Точка2 Цикл
			СледующиеСтроки = ТаблицаГраниц.НайтиСтроки(Новый Структура("НомерКонтура, Точка1", НомерКонтура, Точка2));
			Если СледующиеСтроки.Количество() = 0 Тогда
				ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'В контуре %1 файла данных не замкнуты границы. Геометрия не загружена!'"), НомерКонтура);
			ИначеЕсли СледующиеСтроки.Количество() > 1 Тогда
				ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'В контуре %1 файла данных самопересечение контура. Геометрия не загружена!'"), НомерКонтура);
			КонецЕсли;
			СледующаяСтрока = СледующиеСтроки[0];
			Точка2 = СледующаяСтрока.Точка2;
			КоординатыТочки = Новый Массив;
			КоординатыТочки.Добавить(Точки["НомерКонтура_" + НомерКонтура + "_Номер_" + Точка2].X);
			КоординатыТочки.Добавить(Точки["НомерКонтура_" + НомерКонтура + "_Номер_" + Точка2].Y);
			Контур.Добавить(КоординатыТочки);
		КонецЦикла;

		ТипГеометрииКонтура = "LineString";
		ПоследняяТочка = Контур.Количество() - 1;
		Если Контур.Количество() > 1 И Контур[0][0] = Контур[ПоследняяТочка][0] И Контур[0][1] = Контур[ПоследняяТочка][1] Тогда
			ТипГеометрииКонтура = "Polygon";
		КонецЕсли;
			
		Если Не ЗначениеЗаполнено(ТипГеометрии) Тогда
			ТипГеометрии = ТипГеометрииКонтура;
		КонецЕсли;
		
		Если ТипГеометрии <> ТипГеометрииКонтура Тогда
			ВызватьИсключение "Ошибка преобразования геометрии! Геометрия не загружена!";
		КонецЕсли;
		
		МассивКонтуров.Добавить(Контур);
	КонецЦикла;
	
	Координаты = КонтурыПолучитьКоординатыВНужномФормате(МассивКонтуров, ТипГеометрии);
	
	Возврат Координаты;
КонецФункции

Функция КонтурыДобавитьКоординаты(SpatialElement, ТипДокумента, ТипГеометрии)
	Контур = Новый Массив;
	Elements = ПолучитьЗначениеСвойстваРекурсивно(SpatialElement, "SpelementUnit");
	Если ТипЗнч(Elements) = Тип("СписокXDTO") Тогда
		Для Каждого Element Из Elements Цикл
			КоординатыТочки = Новый Массив;
			КоординатыТочки.Добавить(Число(ПолучитьЗначениеСвойстваРекурсивно(Element, "Ordinate.X")));
			КоординатыТочки.Добавить(Число(ПолучитьЗначениеСвойстваРекурсивно(Element, "Ordinate.Y")));
			Контур.Добавить(КоординатыТочки);
		КонецЦикла;
	ИначеЕсли ТипЗнч(Elements) = Тип("ОбъектXDTO") Тогда
		КоординатыТочки = Новый Массив;
		КоординатыТочки.Добавить(Число(ПолучитьЗначениеСвойстваРекурсивно(Elements, "Ordinate.X")));
		КоординатыТочки.Добавить(Число(ПолучитьЗначениеСвойстваРекурсивно(Elements, "Ordinate.Y")));
		Контур.Добавить(КоординатыТочки);
	КонецЕсли;
	
	ТипГеометрии = "LineString";
	ПоследняяТочка = Контур.Количество() - 1;
	Если Контур.Количество() > 1 И Контур[0][0] = Контур[ПоследняяТочка][0] И Контур[0][1] = Контур[ПоследняяТочка][1] Тогда
		ТипГеометрии = "Polygon";
	КонецЕсли;
	
	Возврат Контур;
КонецФункции

Функция КонтурыДобавить(ТипДокумента, Контур, УчетныйНомер = "", КадастровыйНомер = "")
	ДанныеКонтура = ЗемельныеУчасткиПолучитьСтруктуруДанныхКонтуры();
	
	ДанныеКонтура.ПорядковыйНомер = УчетныйНомер;
	ДанныеКонтура.КадастровыйНомер = КадастровыйНомер;
	
	// HACK делалось только для единого землепользования CompositionEZ (кад выписка 6)
	Если ТипДокумента = Перечисления.гисТипыКадастровыхДокументов.КадастроваяВыписка6 Тогда
		ДатаСнятияСУчета = ПолучитьЗначениеСвойстваРекурсивно(Контур, "DateRemoved");
		Если ЗначениеЗаполнено(ДатаСнятияСУчета) Тогда
			Возврат Неопределено;
		КонецЕсли;
	КонецЕсли;
	
	EntitySpatial = ПолучитьЗначениеСвойстваРекурсивно(Контур, "EntitySpatial");
	Если EntitySpatial = "" Тогда
		Возврат ДанныеКонтура;
	КонецЕсли;
	
	ДанныеКонтура.СистемаКоординат = ПолучитьЗначениеСвойстваРекурсивно(Контур, "EntitySpatial.EntSys");
	
	ЕстьГраницы = ПолучитьЗначениеСвойстваРекурсивно(EntitySpatial, "Borders") <> "";
	Если ЕстьГраницы Тогда 
		Границы = Новый Массив;
		Borders = ПолучитьЗначениеСвойстваРекурсивно(EntitySpatial, "Borders.Border");
		Если ТипЗнч(Borders) = Тип("СписокXDTO") Тогда
			Для Каждого Border Из Borders Цикл
				КонтурыДобавитьГраницы(Границы, Border);
			КонецЦикла;
		ИначеЕсли ТипЗнч(Borders) = Тип("ОбъектXDTO") Тогда
			КонтурыДобавитьГраницы(Границы, Borders);
		КонецЕсли;
		
		Если Границы.Количество() = 0 Тогда
			ЕстьГраницы = Ложь;
		КонецЕсли;
		
		Если ЕстьГраницы Тогда 
			Точки = Новый Структура;
			EntitySpatialElement = ПолучитьЗначениеСвойстваРекурсивно(EntitySpatial, "SpatialElement");
			Если ТипЗнч(EntitySpatialElement) = Тип("СписокXDTO") Тогда
				НомерКонтура = 1;
				Для Каждого SpatialElement Из EntitySpatialElement Цикл
					КонтурыДобавитьТочки(Точки, SpatialElement, ТипДокумента, НомерКонтура);
					НомерКонтура = НомерКонтура + 1;
				КонецЦикла;
			ИначеЕсли ТипЗнч(EntitySpatialElement) = Тип("ОбъектXDTO") Тогда
				КонтурыДобавитьТочки(Точки, EntitySpatialElement, ТипДокумента);
			КонецЕсли;
			
			Для Каждого Граница Из Границы Цикл
				Если Не Точки.Свойство("НомерКонтура_" + Граница.НомерКонтура + "_Номер_" + Граница.Точка1) Или
					Не Точки.Свойство("НомерКонтура_" + Граница.НомерКонтура + "_Номер_" + Граница.Точка2) Тогда
					
					ЕстьГраницы = Ложь;
					Прервать;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
	КонецЕсли;
	
	Координаты = Новый Массив;
	ТипГеометрии = "";
	Если ЕстьГраницы Тогда 
		Координаты = КонтурыЗаполнитьКоординатыПоТочкамИГраницам(Точки, Границы, ТипГеометрии);
	Иначе
		EntitySpatialElement = ПолучитьЗначениеСвойстваРекурсивно(EntitySpatial, "SpatialElement");
		МассивКонтуров = Новый Массив;
		Если ТипЗнч(EntitySpatialElement) = Тип("СписокXDTO") Тогда
			Для Каждого SpatialElement Из EntitySpatialElement Цикл
				ТипГеометрииКонтура = "";
				ТекущийКонтур = КонтурыДобавитьКоординаты(SpatialElement, ТипДокумента, ТипГеометрииКонтура);
				Если Не ЗначениеЗаполнено(ТипГеометрии) Тогда
					ТипГеометрии = ТипГеометрииКонтура;
				КонецЕсли;
				
				Если ТипГеометрии <> ТипГеометрииКонтура Тогда
					ВызватьИсключение "Ошибка преобразования геометрии! Геометрия не загружена!";
				КонецЕсли;
				
				МассивКонтуров.Добавить(ТекущийКонтур);
			КонецЦикла;
		ИначеЕсли ТипЗнч(EntitySpatialElement) = Тип("ОбъектXDTO") Тогда
			ТекущийКонтур = КонтурыДобавитьКоординаты(EntitySpatialElement, ТипДокумента, ТипГеометрии);
			МассивКонтуров.Добавить(ТекущийКонтур);
		КонецЕсли;
		
		Координаты = КонтурыПолучитьКоординатыВНужномФормате(МассивКонтуров, ТипГеометрии);
	КонецЕсли;
	
	ДанныеКонтура.Геометрия = гисГисСервер.ПолучитьGeoJson(Координаты, ТипГеометрии);
	Возврат ДанныеКонтура;
КонецФункции

Процедура КонтурыЗаполнить(Parcel, Контуры, ТипДокумента)
	Контур = ПолучитьЗначениеСвойстваРекурсивно(Parcel, "EntitySpatial");
	Если Контур <> "" Тогда
		ДанныеКонтура = КонтурыДобавить(ТипДокумента, Parcel);
		Если ДанныеКонтура <> Неопределено Тогда
			Контуры.Добавить(ДанныеКонтура);
		КонецЕсли;
	КонецЕсли;
	
	Contours = ПолучитьЗначениеСвойстваРекурсивно(Parcel, "Contours.Contour");
	Если ТипЗнч(Contours) = Тип("СписокXDTO") Тогда
		Для Каждого Contour Из Contours Цикл
			УчетныйНомер = ПолучитьЗначениеСвойстваРекурсивно(Contour, "NumberRecord");
			ДанныеКонтура = КонтурыДобавить(ТипДокумента, Contour, УчетныйНомер);
			Если ДанныеКонтура <> Неопределено Тогда
				Контуры.Добавить(ДанныеКонтура);
			КонецЕсли;
		КонецЦикла;
	ИначеЕсли ТипЗнч(Contours) = Тип("ОбъектXDTO") Тогда
		УчетныйНомер = ПолучитьЗначениеСвойстваРекурсивно(Contours, "NumberRecord");
		ДанныеКонтура = КонтурыДобавить(ТипДокумента, Contours, УчетныйНомер);
		Если ДанныеКонтура <> Неопределено Тогда
			Контуры.Добавить(ДанныеКонтура);
		КонецЕсли;
	КонецЕсли;
	
	EntryParcels = ПолучитьЗначениеСвойстваРекурсивно(Parcel, "CompositionEZ.EntryParcel");
	Если ТипЗнч(EntryParcels) = Тип("СписокXDTO") Тогда
		Для Каждого EntryParcel Из EntryParcels Цикл
			ДанныеКонтура = КонтурыДобавить(ТипДокумента, EntryParcel, , EntryParcel.CadastralNumber);
			Если ДанныеКонтура <> Неопределено Тогда
				Контуры.Добавить(ДанныеКонтура);
			КонецЕсли;
		КонецЦикла;
	ИначеЕсли ТипЗнч(EntryParcels) = Тип("ОбъектXDTO") Тогда
		ДанныеКонтура = КонтурыДобавить(ТипДокумента, EntryParcels, , EntryParcels.CadastralNumber);
		Если ДанныеКонтура <> Неопределено Тогда
			Контуры.Добавить(ДанныеКонтура);
		КонецЕсли;
	КонецЕсли;
КонецПроцедуры

#КонецОбласти

#Область СлужебныеПроцедурыИФункцииЗемельныеУчастки

Функция ЗаполнитьТабличнуюЧастьЗемельныеУчастки(ОбъектXDTO, ТипДокумента, МассивДанныхXml, ИмяИсходногоФайла)
	МассивParcel = Новый Массив;
	
	Попытка
		Если ТипДокумента = Перечисления.гисТипыКадастровыхДокументов.КадастроваяВыписка6 Или
			 ТипДокумента = Перечисления.гисТипыКадастровыхДокументов.КадастроваяВыписка7 Тогда 
			ПолучитьParcelПоCadastralBlock(ОбъектXDTO, МассивParcel);
		ИначеЕсли ТипДокумента = Перечисления.гисТипыКадастровыхДокументов.КадастровыйПаспорт5 Или
			 	  ТипДокумента = Перечисления.гисТипыКадастровыхДокументов.КадастровыйПаспорт6 Тогда
			МассивParcel.Добавить(ОбъектXDTO.Parcel);
		ИначеЕсли ТипДокумента = Перечисления.гисТипыКадастровыхДокументов.КадастровыйПлан9 Или
				  ТипДокумента = Перечисления.гисТипыКадастровыхДокументов.КадастровыйПлан10 Тогда
			ПолучитьParcelПоCadastralDistrict(ОбъектXDTO, МассивParcel);
		КонецЕсли;
	Исключение
		ОбщегоНазначения.СообщитьПользователю(?(ЗначениеЗаполнено(ИмяИсходногоФайла), ИмяИсходногоФайла + Символы.ПС, "") + "Некорректная xml! Земельные участки не загружены!");
		Возврат Ложь;
	КонецПопытки;
	
	Для Каждого Parcel Из МассивParcel Цикл
		Попытка
			ДанныеXml = ОбработатьParcel(ОбъектXDTO, Parcel, ТипДокумента);
		Исключение
			ОбщегоНазначения.СообщитьПользователю(?(ЗначениеЗаполнено(ИмяИсходногоФайла), ИмяИсходногоФайла + Символы.ПС, "") + "Земельные участки" + Символы.ПС + ОписаниеОшибки());
			Возврат Ложь;
		КонецПопытки;
		МассивДанныхXml.Добавить(ДанныеXml);
	КонецЦикла;
	
	Возврат Истина;
КонецФункции

Функция ОбработатьParcel(ОбъектXDTO, Parcel, ТипДокумента)
	ДанныеXml = ЗемельныеУчасткиПолучитьСтруктуруДанныхXml();
	
	КадастровыйНомер = ПолучитьЗначениеСвойстваРекурсивно(Parcel, "CadastralNumber");
	Если Лев(КадастровыйНомер, 1) = ":" Тогда
		Попытка
			КадастровыйНомер = Parcel.Владелец().Владелец().CadastralNumber + КадастровыйНомер;
		Исключение
		КонецПопытки;
	КонецЕсли;
	ДанныеXml.КадастровыйНомер = КадастровыйНомер;
	
	ДанныеXml.ВидУчасткаКод = ПолучитьЗначениеСвойстваРекурсивно(Parcel, "Name");
	ДанныеXml.СтатусКод = ПолучитьЗначениеСвойстваРекурсивно(Parcel, "State");

	ДатаСозданияДокумента = ПолучитьЗначениеСвойстваРекурсивно(Parcel, "DateCreated");
	Если ДатаСозданияДокумента = "" Тогда
		ДатаВыписки = ПолучитьДатуДокументаПоОбъекту(ОбъектXDTO);
		ДанныеXml.ДатаПостановкиНаУчет = Дата("00010101");
	Иначе
		ДатаВыписки = Дата(СтрЗаменить(ДатаСозданияДокумента, "-", ""));
		ДанныеXml.ДатаПостановкиНаУчет = ДатаВыписки;
	КонецЕсли;
	
	ДанныеXml.ПредыдущийКадастровыйНомер = ПолучитьЗначениеСвойстваРекурсивно(Parcel, "OldNumbers.OldNumber.Number");
	ДанныеXml.КатегорияЗемельКод = ПолучитьЗначениеСвойстваРекурсивно(Parcel, "Category");	
	
	Utilization = ПолучитьЗначениеСвойстваРекурсивно(Parcel, "Utilization");
	Если Utilization <> "" Тогда
		ДанныеXml.ВидИспользованияКод = ПолучитьЗначениеСвойстваРекурсивно(Utilization, "Utilization");
		ДанныеXml.ВидИспользованияПоДокументу = ПолучитьЗначениеСвойстваРекурсивно(Utilization, "ByDoc");
	КонецЕсли;
	
	ДанныеXml.Комментарий = ПолучитьЗначениеСвойстваРекурсивно(Parcel, "SpecialNote");
	
	Address = ПолучитьЗначениеСвойстваРекурсивно(Parcel, "Location.Address");
	Если Address <> "" Тогда
		ДанныеАдреса = АдресСформировать(Address, Справочники.ВидыКонтактнойИнформации.ПочтовыйАдресКадастровогоЗемельногоУчастка);
		ДанныеXml.Адрес = ДанныеАдреса.Представление;
		ДанныеXml.АдресЗначенияПолей = ДанныеАдреса.ЗначенияПолей;
		ДанныеXml.АдресЗначение = ДанныеАдреса.Значение;
		
		ДанныеXml.ОКАТО = ПолучитьЗначениеСвойстваРекурсивно(Address, "OKATO");
		ДанныеXml.ОКТМО = ПолучитьЗначениеСвойстваРекурсивно(Address, "OKTMO");
	КонецЕсли;
	
	Area = ПолучитьЗначениеСвойстваРекурсивно(Parcel, "Area");
	Если Area <> "" Тогда
		Unit = ПолучитьЗначениеСвойстваРекурсивно(Area, "Unit");
		Площадь = ПолучитьЗначениеСвойстваРекурсивно(Area, "Area");
		Если Unit = "055" Тогда
			ДанныеXml.Площадь = Площадь;
		КонецЕсли;
	КонецЕсли;
	
	CadastralCost = ПолучитьЗначениеСвойстваРекурсивно(Parcel, "CadastralCost");
	Если CadastralCost <> "" Тогда
		Unit = ПолучитьЗначениеСвойстваРекурсивно(CadastralCost, "Unit");
		Value = ПолучитьЗначениеСвойстваРекурсивно(CadastralCost, "Value");
		Если Unit = "383" Тогда
			ДанныеXml.КадастроваяСтоимость = Value;
		КонецЕсли;
	КонецЕсли;
	
	ПраваНаУчасток = Новый Массив;
	Rights = ПолучитьЗначениеСвойстваРекурсивно(Parcel, "Rights.Right");
	Если ТипЗнч(Rights) = Тип("СписокXDTO") Тогда
		Для Каждого Right Из Rights Цикл
			ПравНаУчастокЗаполнить(Right, ДатаВыписки, ПраваНаУчасток, ДанныеXml.Площадь);
		КонецЦикла;
	ИначеЕсли ТипЗнч(Rights) = Тип("ОбъектXDTO") Тогда
		ПравНаУчастокЗаполнить(Rights, ДатаВыписки, ПраваНаУчасток, ДанныеXml.Площадь);
	КонецЕсли;
	ДанныеXml.ПраваНаУчасток = ПраваНаУчасток;
	
	Контуры = Новый Массив;
	Попытка
		КонтурыЗаполнить(Parcel, Контуры, ТипДокумента);
		Для Каждого ТекущийКонтур Из Контуры Цикл
			Если Не ЗначениеЗаполнено(ТекущийКонтур.СистемаКоординат) Тогда
				ЗаполнитьСистемуКоординат(ОбъектXDTO, Parcel, ТекущийКонтур, ТипДокумента);
			КонецЕсли;
		КонецЦикла;
	Исключение
		ОбщегоНазначения.СообщитьПользователю("Ошибка при загрузке земельного участка " + ДанныеXml.КадастровыйНомер + Символы.ПС + ОписаниеОшибки());
	КонецПопытки;
	ДанныеXml.Контуры = Контуры;
	
	// даты в полях: ДатаПостановкиНаУчет, Период
	Возврат ДанныеXml;
КонецФункции

// получение массива Parcel

Процедура ПолучитьParcelПоCadastralBlock(CadastralBlock, МассивParcel)
	Parcel = ПолучитьЗначениеСвойстваРекурсивно(CadastralBlock, "Parcels.Parcel");
	
	Если ТипЗнч(Parcel) = Тип("СписокXDTO") Тогда
		Для Каждого Участок Из Parcel Цикл
			МассивParcel.Добавить(Участок);
		КонецЦикла;
	ИначеЕсли ТипЗнч(Parcel) = Тип("ОбъектXDTO") Тогда
		МассивParcel.Добавить(Parcel);
	КонецЕсли;
КонецПроцедуры

Процедура ПолучитьParcelПоCadastralDistrict(CadastralDistrict, МассивParcel)
	CadastralBlocks = ПолучитьЗначениеСвойстваРекурсивно(CadastralDistrict, "CadastralBlocks.CadastralBlock");
	
	Если ТипЗнч(CadastralBlocks) = Тип("СписокXDTO") Тогда
		Для Каждого CadastralBlock Из CadastralBlocks Цикл
			ПолучитьParcelПоCadastralBlock(CadastralBlock, МассивParcel);
		КонецЦикла;
	ИначеЕсли ТипЗнч(CadastralBlocks) = Тип("ОбъектXDTO") Тогда
		ПолучитьParcelПоCadastralBlock(CadastralBlocks, МассивParcel);
	КонецЕсли;
КонецПроцедуры

#Область СлужебныеПроцедурыИФункцииЗемельныеУчасткиПраваНаУчасток

Функция ПолучитьПлощадьДоли(Числитель, Знаменатель, Площадь)
	Возврат ?(Знаменатель = 0, 0, Площадь * Числитель / Знаменатель);
КонецФункции

Функция ПраваНаУчастокДокументыПолучитьДанные(Document)
	ДанныеДокументов = ЗемельныеУчасткиПолучитьСтруктуруДанныхПраваНаУчастокДокументы();
	ЗаполнитьЗначенияСвойств(ДанныеДокументов, Document);
	
	Попытка
		ДанныеДокументов.Date = Дата(СтрЗаменить(Document.Date, "-", ""));
	Исключение
		ДанныеДокументов.Date = Дата("00010101");
	КонецПопытки;

	Возврат ДанныеДокументов;
КонецФункции

Функция ПраваНаУчастокЗаполнитьПравообладателя(Owner, ПраваНаУчасток)
	// организации
	
	Организация = ПолучитьЗначениеСвойстваРекурсивно(Owner, "Organization");
	Если Организация <> "" Тогда
		ПраваНаУчасток.ПравообладательНаименование = СокрЛП(ПолучитьЗначениеСвойстваРекурсивно(Организация, "Name"));
		ПраваНаУчасток.ПравообладательТип = 1;
	КонецЕсли;
	
	// физические лица
	
	ФизическоеЛицо = ПолучитьЗначениеСвойстваРекурсивно(Owner, "Person.FIO");
	Если ФизическоеЛицо <> "" Тогда
		// выписка 4, 5, паспорт 3, 4
		ПраваНаУчасток.ПравообладательФамилия = СокрЛП(ПолучитьЗначениеСвойстваРекурсивно(ФизическоеЛицо, "Surname"));
		ПраваНаУчасток.ПравообладательИмя = СокрЛП(ПолучитьЗначениеСвойстваРекурсивно(ФизическоеЛицо, "First"));
		ПраваНаУчасток.ПравообладательОтчество = СокрЛП(ПолучитьЗначениеСвойстваРекурсивно(ФизическоеЛицо, "Patronymic"));
		ПраваНаУчасток.ПравообладательТип = 2;
	КонецЕсли;
	
	ФизическоеЛицо = ПолучитьЗначениеСвойстваРекурсивно(Owner, "Person");
	Если ФизическоеЛицо <> "" Тогда
		// выписка 6, паспорт 5
		ПраваНаУчасток.ПравообладательФамилия = СокрЛП(ПолучитьЗначениеСвойстваРекурсивно(ФизическоеЛицо, "FamilyName"));
		ПраваНаУчасток.ПравообладательИмя = СокрЛП(ПолучитьЗначениеСвойстваРекурсивно(ФизическоеЛицо, "FirstName"));
		ПраваНаУчасток.ПравообладательОтчество = СокрЛП(ПолучитьЗначениеСвойстваРекурсивно(ФизическоеЛицо, "Patronymic"));
		ПраваНаУчасток.ПравообладательТип = 2;
	КонецЕсли;
	
	// публичное право
	
	Учреждение = ПолучитьЗначениеСвойстваРекурсивно(Owner, "Governance");
	Если Учреждение <> "" Тогда
		ПраваНаУчасток.ПравообладательНаименование = СокрЛП(ПолучитьЗначениеСвойстваРекурсивно(Учреждение, "Name"));
		ПраваНаУчасток.ПравообладательТип = 3;
	КонецЕсли;
КонецФункции

Функция ПраваНаУчастокДобавить(Right, ДатаВыписки, Owner, Площадь)
	Share = ПолучитьЗначениеСвойстваРекурсивно(Right, "Share");
	Если Share = "" Тогда
		ЧислительДробиДоли = 0;
		ЗнаменательДробиДоли = 0;
	Иначе
		// выписка 6, паспорт 5
		ЧислительДробиДоли = Right.Share.Numerator;
		ЗнаменательДробиДоли = Right.Share.Denominator;
	КонецЕсли;
	
	Комментарий = ПолучитьЗначениеСвойстваРекурсивно(Right, "ShareText");
	Если Не ЗначениеЗаполнено(Комментарий) Тогда
		Комментарий = ПолучитьЗначениеСвойстваРекурсивно(Right, "Desc");
	КонецЕсли;
	Если Не ЗначениеЗаполнено(Комментарий) Тогда
		Комментарий = ПолучитьЗначениеСвойстваРекурсивно(Right, "Name");
	КонецЕсли;
	
	ДанныеПраваНаУчасток = ЗемельныеУчасткиПолучитьСтруктуруДанныхПраваНаУчасток();
	ДанныеПраваНаУчасток.ВидПраваКод = Right.Type;
	ДанныеПраваНаУчасток.Комментарий = Комментарий;
	ДанныеПраваНаУчасток.ЧислительДробиДоли = ЧислительДробиДоли;
	ДанныеПраваНаУчасток.ЗнаменательДробиДоли = ЗнаменательДробиДоли;
	ДанныеПраваНаУчасток.ПлощадьДоли = ПолучитьПлощадьДоли(ЧислительДробиДоли, ЗнаменательДробиДоли, Площадь);
	
	ДанныеПраваНаУчасток.Период = ПолучитьЗначениеСвойстваРекурсивно(Right, "Registration.RegDate");
	ДанныеПраваНаУчасток.НомерГРП = ПолучитьЗначениеСвойстваРекурсивно(Right, "Registration.RegNumber");
	
	ПраваНаУчастокЗаполнитьПравообладателя(Owner, ДанныеПраваНаУчасток);
	
	ДокументыПоПравам = Новый Массив;
	ДокументыФайла = ПолучитьЗначениеСвойстваРекурсивно(Right, "Documents.Document");
	// выписка 6, паспорт 5
	Если ТипЗнч(ДокументыФайла) = Тип("СписокXDTO") Тогда
		Для Каждого Document Из ДокументыФайла Цикл
			ДанныеДокументов = ПраваНаУчастокДокументыПолучитьДанные(Document);
			ДокументыПоПравам.Добавить(ДанныеДокументов);
			Если Не ЗначениеЗаполнено(ДанныеПраваНаУчасток.Период) И ЗначениеЗаполнено(ДанныеДокументов.Date) Тогда
				ДанныеПраваНаУчасток.Период = ДанныеДокументов.Date;
			КонецЕсли;
		КонецЦикла;
	ИначеЕсли ТипЗнч(ДокументыФайла) = Тип("ОбъектXDTO") Тогда
		ДанныеДокументов = ПраваНаУчастокДокументыПолучитьДанные(ДокументыФайла);
		ДокументыПоПравам.Добавить(ДанныеДокументов);
		Если Не ЗначениеЗаполнено(ДанныеПраваНаУчасток.Период) И ЗначениеЗаполнено(ДанныеДокументов.Date) Тогда
			ДанныеПраваНаУчасток.Период = ДанныеДокументов.Date;
		КонецЕсли;
	КонецЕсли;
	// даты в полях: Date
	ДанныеПраваНаУчасток.Документы = гисРаботаСJson.ЗаписатьНативно(ДокументыПоПравам);
	
	Если Не ЗначениеЗаполнено(ДанныеПраваНаУчасток.Период) Тогда
		ДанныеПраваНаУчасток.Период = ДатаВыписки;
	КонецЕсли;
	
	Возврат ДанныеПраваНаУчасток;
КонецФункции

Процедура ПравНаУчастокЗаполнить(Right, ДатаВыписки, ПраваНаУчасток, Площадь)
	Owners = ПолучитьЗначениеСвойстваРекурсивно(Right, "Owners.Owner");
	
	Если ТипЗнч(Owners) = Тип("СписокXDTO") Тогда
		Для Каждого Owner Из Owners Цикл
			ДанныеПраваНаУчасток = ПраваНаУчастокДобавить(Right, ДатаВыписки, Owner, Площадь);
			ПраваНаУчасток.Добавить(ДанныеПраваНаУчасток);
		КонецЦикла;
	ИначеЕсли ТипЗнч(Owners) = Тип("ОбъектXDTO") Тогда
		ДанныеПраваНаУчасток = ПраваНаУчастокДобавить(Right, ДатаВыписки, Owners, Площадь);
		ПраваНаУчасток.Добавить(ДанныеПраваНаУчасток);
	КонецЕсли;
КонецПроцедуры

#КонецОбласти

#Область СлужебныеПроцедурыИФункцииЗемельныеУчасткиСистемаКоординат

Процедура ЗаполнитьСистемуКоординат(ОбъектXDTO, Parcel, ТекущийКонтур, ТипДокумента)
	Если ТипДокумента = Перечисления.гисТипыКадастровыхДокументов.КадастроваяВыписка6 Или
		ТипДокумента = Перечисления.гисТипыКадастровыхДокументов.КадастровыйПаспорт5 Тогда
		
		Попытка
			СистемыКоординат = ОбъектXDTO.CoordSystems.CoordSystem;
			Если ТипЗнч(СистемыКоординат) = Тип("ОбъектXDTO") Тогда
				// если один - берем, иначе не рассматриваем
				ТекущийКонтур.СистемаКоординат = СистемыКоординат.CsId;
			КонецЕсли;
		Исключение
		КонецПопытки;
	ИначеЕсли ТипДокумента = Перечисления.гисТипыКадастровыхДокументов.КадастровыйПлан9 Тогда
		Попытка
			СистемыКоординат = Parcel.Владелец().Владелец().CoordSystems.CoordSystem;
			Если ТипЗнч(СистемыКоординат) = Тип("ОбъектXDTO") Тогда
				// если один - берем, иначе не рассматриваем
				ТекущийКонтур.СистемаКоординат = СистемыКоординат.CsId;
			КонецЕсли;
		Исключение
		КонецПопытки;
	КонецЕсли;
КонецПроцедуры

#КонецОбласти

#КонецОбласти

#Область Адрес

// Формирует значения для реквизитов "Представление" и "ЗначенияПолей" т.ч. "КонтактнаяИнформация"
// из объекта, содержащего адрес, пришедшего из Росреестра.
//
// Параметры:
//  Address	 - ОбъектXDTO	 - адрес типа tAddress или tAddressOut, который приходит с Росреестра.
// 
// Возвращаемое значение:
//   - Структура со свойствами
//		Представление - Строка - для реквизита "Представление" т.ч. "КонтактнаяИнформация";
//		ЗначенияПолей - Строка - для реквизита "ЗначенияПолей" т.ч. "КонтактнаяИнформация";
// 		Значение	  - Строка - для реквизита "Значение" т.ч. "КонтактнаяИнформация".
//
// Если получить "ЗначенияПолей" не удалось - бросает исключение.
//
Функция АдресСформировать(Address, ВидКонтактнойИнформации)
	// программное формирование полей адреса
	ПоляАдреса = РаботаСАдресамиКлиентСервер.ПоляАдреса();
	
	// заполнение полей
	ПоляАдреса.ТипАдреса = "Административно-территориальный";
	ПоляАдреса.Комментарий = ПолучитьЗначениеСвойстваРекурсивно(Address, "Note");
	
	ПоляАдреса.Страна = Справочники.СтраныМира.Россия.Наименование;
	ПоляАдреса.КодСтраны = Справочники.СтраныМира.Россия.Код;
	
	Индекс = ПолучитьЗначениеСвойстваРекурсивно(Address, "Postal_Code");
	Если Индекс = "" Тогда
		Индекс = ПолучитьЗначениеСвойстваРекурсивно(Address, "PostalCode");
	КонецЕсли;
	ПоляАдреса.Индекс = Индекс;
	
	Region = ПолучитьЗначениеСвойстваРекурсивно(Address, "Region");
	ПоляАдреса.КодРегиона = Region;
	Если Region <> "" Тогда
		ПоляАдреса.Регион = АдресныйКлассификатор.НаименованиеРегионаПоКоду(Region);
	КонецЕсли;
	
	ПоляАдреса.Район = ПолучитьЗначениеСвойстваРекурсивно(Address, "District.Name");
	ПоляАдреса.РайонСокращение = ПолучитьЗначениеСвойстваРекурсивно(Address, "District.Type");
	ПоляАдреса.Город = ПолучитьЗначениеСвойстваРекурсивно(Address, "City.Name");
	ПоляАдреса.ГородСокращение = ПолучитьЗначениеСвойстваРекурсивно(Address, "City.Type");
	ПоляАдреса.НаселенныйПункт = ПолучитьЗначениеСвойстваРекурсивно(Address, "Locality.Name");
	ПоляАдреса.НаселенныйПунктСокращение = ПолучитьЗначениеСвойстваРекурсивно(Address, "Locality.Type");
	ПоляАдреса.Улица = ПолучитьЗначениеСвойстваРекурсивно(Address, "Street.Name");
	ПоляАдреса.УлицаСокращение = ПолучитьЗначениеСвойстваРекурсивно(Address, "Street.Type");
	
	UrbanDistrict = ПолучитьЗначениеСвойстваРекурсивно(Address, "Urban_District");
	Если UrbanDistrict = "" Тогда
		UrbanDistrict = ПолучитьЗначениеСвойстваРекурсивно(Address, "UrbanDistrict");
	КонецЕсли;
	Если UrbanDistrict <> "" Тогда
		ПоляАдреса.ВнутригородскойРайон = ПолучитьЗначениеСвойстваРекурсивно(UrbanDistrict, "Name");
		ПоляАдреса.ВнутригородскойРайонСокращение = ПолучитьЗначениеСвойстваРекурсивно(UrbanDistrict, "Type");
	КонецЕсли;
	
	Level1 = ПолучитьЗначениеСвойстваРекурсивно(Address, "Level1");
	Если Level1 <> "" Тогда
		ТипЗдания = ПолучитьЗначениеСвойстваРекурсивно(Level1, "Type");
		Если ТипЗдания = "д" Тогда
			ПоляАдреса.Здание.ТипЗдания = "Дом";
		ИначеЕсли ТипЗдания = "вл" Тогда
			ПоляАдреса.Здание.ТипЗдания = "Владение";
		Иначе
			ПоляАдреса.Здание.ТипЗдания = ТипЗдания;
		КонецЕсли;
		ПоляАдреса.Здание.Номер = ПолучитьЗначениеСвойстваРекурсивно(Level1, "Value");
	КонецЕсли;
	
	Level2 = ПолучитьЗначениеСвойстваРекурсивно(Address, "Level2");
	Если Level2 <> "" Тогда
		Type = ПолучитьЗначениеСвойстваРекурсивно(Level2, "Type");
		Если Type = "корп" Тогда
			ТипКорпуса = "Корпус";
		ИначеЕсли Type = "строение" Тогда
			ТипКорпуса = "Строение";
		ИначеЕсли Type = "сооружение" Тогда
			ТипКорпуса = "Сооружение";
		ИначеЕсли Type = "уч" Тогда
			ТипКорпуса = "Участок";
		Иначе
			ТипКорпуса = Type;
		КонецЕсли;
		Номер = ПолучитьЗначениеСвойстваРекурсивно(Level2, "Value");
		Корпус = Новый Структура("Тип,Номер", ТипКорпуса, Номер);
		ПоляАдреса.Корпуса.Добавить(Корпус); 
	КонецЕсли;
	
	// Level3 не проверяем
	
	Apartment = ПолучитьЗначениеСвойстваРекурсивно(Address, "Apartment");
	Если Apartment <> "" Тогда
		Type = ПолучитьЗначениеСвойстваРекурсивно(Apartment, "Type");
		Если Type = "кв" Тогда
			ТипПомещения = "Квартира";
		ИначеЕсли Type = "бокс" Тогда
			ТипПомещения = "Бокс";
		ИначеЕсли Type = "к" Тогда
			ТипПомещения = "Комната";
		ИначеЕсли Type = "пом" Тогда
			ТипПомещения = "Помещение";
		Иначе
			ТипПомещения = Type;
		КонецЕсли;
		Номер = ПолучитьЗначениеСвойстваРекурсивно(Apartment, "Value");
		Помещение = Новый Структура("Тип,Номер", ТипПомещения, Номер);
		ПоляАдреса.Помещения.Добавить(Помещение);
	КонецЕсли;
	
	ОКТМО = ПолучитьЗначениеСвойстваРекурсивно(Address, "Code_OKTMO");
	Если Не ЗначениеЗаполнено(ОКТМО) Тогда
		ОКТМО = ПолучитьЗначениеСвойстваРекурсивно(Address, "OKTMO");
	КонецЕсли;
	ПоляАдреса.ДополнительныеКоды.ОКТМО = ОКТМО;
	
	OKATO = ПолучитьЗначениеСвойстваРекурсивно(Address, "Code_OKATO");
	Если Не ЗначениеЗаполнено(OKATO) Тогда
		OKATO = ПолучитьЗначениеСвойстваРекурсивно(Address, "OKATO");
	КонецЕсли;
	ПоляАдреса.ДополнительныеКоды.ОКАТО = OKATO;
	
	ЗначенияПолей			= УправлениеКонтактнойИнформацией.КонтактнаяИнформацияВXML(ПоляАдреса, "", Перечисления.ТипыКонтактнойИнформации.Адрес);
	Значение				= УправлениеКонтактнойИнформацией.КонтактнаяИнформацияВJSON(ПоляАдреса, ВидКонтактнойИнформации);
	Представление			= УправлениеКонтактнойИнформацией.ПредставлениеКонтактнойИнформации(Значение);
	
	СтруктураЗначение		= УправлениеКонтактнойИнформациейСлужебный.СтрокуJSONВСтруктуру(Значение);
	СтруктураЗначение.value = Представление;
	Значение				= УправлениеКонтактнойИнформациейСлужебный.СтруктураВСтрокуJSON(СтруктураЗначение);
	
	Возврат Новый Структура("ЗначенияПолей,Значение,Представление", ЗначенияПолей, Значение, Представление);
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункцииРосреестр

Процедура ЗаполнитьДанныеXml(ДанныеXml, feature)
	Если feature.Свойство("parcelData") Тогда
		ДанныеУчастка = feature.parcelData;
		
		ДанныеУчастка.Свойство("parcelCn", 		ДанныеXml.КадастровыйНомер);
		ДанныеУчастка.Свойство("parcelStatus",	ДанныеXml.СтатусКод);
		ДанныеУчастка.Свойство("categoryType",	ДанныеXml.КатегорияЗемельКод); 
		ДанныеУчастка.Свойство("utilCode",		ДанныеXml.ВидИспользованияКод);
		ДанныеУчастка.Свойство("utilByDoc",		ДанныеXml.ВидИспользованияПоДокументу);
		ДанныеУчастка.Свойство("areaValue",		ДанныеXml.Площадь);
		
		// дата постановки на учет
		ДатаПостановкиСтрока = "";
		ДанныеУчастка.Свойство("dateCreate",	ДатаПостановкиСтрока);
		Если Не ПустаяСтрока(ДатаПостановкиСтрока) Тогда
			ДанныеXml.ДатаПостановкиНаУчет = гисОбщегоНазначенияКлиентСервер.ПеревестиСтрокуВДату(ДатаПостановкиСтрока);
		КонецЕсли;
		
		// кадастровая стоимость
		КадастроваяСтоимость = 0;
		ДанныеУчастка.Свойство("cadCost",		КадастроваяСтоимость);
		
		// адрес
		Если feature.Свойство("objectData") Тогда
			ДанныеОбъекта = feature.objectData;
			ДанныеОбъекта.Свойство("addressNote", ДанныеXml.Адрес); 
		КонецЕсли;
	КонецЕсли;
КонецПроцедуры

#КонецОбласти

#КонецОбласти
